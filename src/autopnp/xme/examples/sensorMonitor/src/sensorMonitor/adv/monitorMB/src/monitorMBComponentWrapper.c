/*
 * Copyright (c) 2011-2014, fortiss GmbH.
 * Licensed under the Apache License, Version 2.0.
 *
 * Use, modification and distribution are subject to the terms specified
 * in the accompanying license file LICENSE.txt located at the root directory
 * of this software distribution. A copy is available at
 * http://chromosome.fortiss.org/.
 *
 * This file is part of CHROMOSOME.
 *
 * $Id: monitorMBComponentWrapper.c 7769 2014-03-11 15:27:13Z geisinger $
 */

/**
 * \file
 *         Component wrapper - implements interface of a component
 *              to the data handler
 *
 * \author
 *         This file has been generated by the CHROMOSOME Modeling Tool (XMT)
 *         (fortiss GmbH).
 */

/******************************************************************************/
/***   Includes                                                             ***/
/******************************************************************************/
#include "sensorMonitor/adv/monitorMB/include/monitorMBComponentWrapper.h"

#include "xme/core/dataHandler/include/dataHandler.h"
#include "xme/core/log.h"

#ifdef XME_MULTITHREAD
#include "xme/hal/include/tls.h"
#endif // #ifdef XME_MULTITHREAD

/******************************************************************************/
/***   Type definitions                                                     ***/
/******************************************************************************/
/**
 * \brief Structure for storing information about the input ports.
 */
typedef struct
{
    xme_core_dataManager_dataPacketId_t dataPacketId; ///< The data packet id.
    xme_core_component_portState_t state; ///< State of the port. Denotes whether the port is locked, whether data and/or attributes have been read from it and whether an error occurred.
} inputPort_t;

/******************************************************************************/
/***   Variables                                                            ***/
/******************************************************************************/
/**
 * \brief Number of times this component wrapper has been initialized.
 */
static uint16_t initializationCount = 0U;

/**
 * \brief Array storing information about the input ports.
 */
static inputPort_t inputPorts[] = {
    {XME_CORE_DATAMANAGER_DATAPACKETID_INVALID, { 0U } } // monitorMB.sensorValueIn
};

/**
 * \brief Size of inputPorts array.
 */
static const uint8_t inputPortCount = sizeof(inputPorts) / sizeof(inputPorts[0]);

#ifdef XME_MULTITHREAD
static xme_hal_tls_handle_t inputPortAccessed = XME_HAL_TLS_INVALID_TLS_HANDLE; ///< Bitmap storing whether a specific thread has accessed an input port in multithreading scenarios.
#endif // #ifdef XME_MULTITHREAD

/******************************************************************************/
/***   Implementation                                                       ***/
/******************************************************************************/
xme_status_t
sensorMonitor_adv_monitorMB_monitorMBComponentWrapper_init(void)
{
    if (0U == initializationCount)
    {
        #ifdef XME_MULTITHREAD
        if (XME_HAL_TLS_INVALID_TLS_HANDLE == inputPortAccessed)
        {
            inputPortAccessed = xme_hal_tls_alloc((inputPortCount + 7U) / 8U);
            XME_ASSERT(XME_HAL_TLS_INVALID_TLS_HANDLE != inputPortAccessed);
        }
        #endif // #ifdef XME_MULTITHREAD
    }

    initializationCount++;

    return XME_STATUS_SUCCESS;
}

void
sensorMonitor_adv_monitorMB_monitorMBComponentWrapper_fini(void)
{
    XME_ASSERT_NORVAL(initializationCount > 0U);
    initializationCount--;

    if (0U == initializationCount)
    {
        #ifdef XME_MULTITHREAD
        if (XME_HAL_TLS_INVALID_TLS_HANDLE != inputPortAccessed)
        {
            xme_hal_tls_free(inputPortAccessed);
        }
        #endif // #ifdef XME_MULTITHREAD
    }
}

xme_status_t
sensorMonitor_adv_monitorMB_monitorMBComponentWrapper_receivePort
(
    xme_core_dataManager_dataPacketId_t dataPacketId,
    sensorMonitor_adv_monitorMB_monitorMBComponentWrapper_internalPortId_t componentInternalPortId
)
{
    XME_CHECK
    (
        inputPortCount > componentInternalPortId,
        XME_STATUS_INVALID_PARAMETER
    );

    {
        inputPorts[componentInternalPortId].dataPacketId = dataPacketId;
        inputPorts[componentInternalPortId].state.dataValid = 0;
        inputPorts[componentInternalPortId].state.attributesValid = 0;
        inputPorts[componentInternalPortId].state.locked = 0;
        inputPorts[componentInternalPortId].state.error = 0;
    }

    return XME_STATUS_SUCCESS;
}

void
sensorMonitor_adv_monitorMB_monitorMBComponentWrapper_completeReadOperations(void)
{
    uint8_t inputPortIndex;

    for (inputPortIndex = 0U; inputPortIndex < inputPortCount; inputPortIndex++)
    {
        // This is a no-operation in case the port has not been read
        (void) sensorMonitor_adv_monitorMB_monitorMBComponentWrapper_readNextPacket(inputPortIndex);
    }
}

xme_status_t
sensorMonitor_adv_monitorMB_monitorMBComponentWrapper_readPortSensorValueIn
(
    const sensorMonitor_topic_sensorData_t* data
)
{
    uint8_t inputPortIndex;
    unsigned int bytesRead;
    xme_status_t status;
#ifdef XME_MULTITHREAD
    char* accessed;
#endif // #ifdef XME_MULTITHREAD

    XME_CHECK(NULL != data, XME_STATUS_INVALID_PARAMETER);

    inputPortIndex = (uint8_t)SENSORMONITOR_ADV_MONITORMB_MONITORMBCOMPONENTWRAPPER_PORT_SENSORVALUEIN;

#ifdef XME_MULTITHREAD
    XME_ASSERT(inputPortAccessed != XME_HAL_TLS_INVALID_TLS_HANDLE);
    accessed = (char*) xme_hal_tls_get(inputPortAccessed);
    XME_ASSERT(NULL != accessed);

    if (!(accessed[inputPortIndex / 8U] & (1 << (inputPortIndex % 8U))))
#else // #ifdef XME_MULTITHREAD
    if (!inputPorts[inputPortIndex].state.locked)
#endif // #ifdef XME_MULTITHREAD
    {
        status = xme_core_dataHandler_startReadOperation(inputPorts[inputPortIndex].dataPacketId);
        XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
#ifdef XME_MULTITHREAD
        accessed[inputPortIndex / 8U] |= (1 << (inputPortIndex % 8U));
#endif // #ifdef XME_MULTITHREAD
        inputPorts[inputPortIndex].state.locked = 1;
    }

    status = xme_core_dataHandler_readData
    (
        inputPorts[inputPortIndex].dataPacketId,
        (void*)data,
        (uint32_t)sizeof(sensorMonitor_topic_sensorData_t),
        &bytesRead
    );

    if (XME_STATUS_SUCCESS == status)
    {
        inputPorts[inputPortIndex].state.dataValid = 1;
    }
    else
    {
        inputPorts[inputPortIndex].state.error = 1;
    }

    return status;
}

xme_status_t
sensorMonitor_adv_monitorMB_monitorMBComponentWrapper_readInputPortAttribute
(
    sensorMonitor_adv_monitorMB_monitorMBComponentWrapper_internalPortId_t portId,
    xme_core_attribute_key_t attributeKey,
    void* const buffer,
    uint32_t bufferSize
)
{
    xme_status_t status;
    uint8_t inputPortIndex;
    uint32_t bytesRead = 0U;
#ifdef XME_MULTITHREAD
    char* accessed;
#endif // #ifdef XME_MULTITHREAD

    inputPortIndex = (uint8_t)portId;

#ifdef XME_MULTITHREAD
    XME_ASSERT(inputPortAccessed != XME_HAL_TLS_INVALID_TLS_HANDLE);
    accessed = (char*) xme_hal_tls_get(inputPortAccessed);
    XME_ASSERT(NULL != accessed);

    if (!(accessed[inputPortIndex / 8U] & (1 << (inputPortIndex % 8U))))
#else // #ifdef XME_MULTITHREAD
    if (!inputPorts[inputPortIndex].state.locked)
#endif // #ifdef XME_MULTITHREAD
    {
        status = xme_core_dataHandler_startReadOperation(inputPorts[inputPortIndex].dataPacketId);
        XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
#ifdef XME_MULTITHREAD
        accessed[inputPortIndex / 8U] |= (1 << (inputPortIndex % 8U));
#endif // #ifdef XME_MULTITHREAD
        inputPorts[inputPortIndex].state.locked = 1;
    }

    status = xme_core_dataHandler_readAttribute
    (
        inputPorts[inputPortIndex].dataPacketId,
        attributeKey,
        buffer,
        bufferSize,
        &bytesRead
    );

    if (XME_STATUS_SUCCESS == status)
    {
        inputPorts[inputPortIndex].state.attributesValid = 1;
    }

    // FIXME: Check bytesRead

    return status;
}

xme_status_t
sensorMonitor_adv_monitorMB_monitorMBComponentWrapper_readNextPacket
(
    sensorMonitor_adv_monitorMB_monitorMBComponentWrapper_internalPortId_t portId
)
{
    xme_status_t status = XME_STATUS_SUCCESS;
#ifdef XME_MULTITHREAD
    char* accessed;
#endif // #ifdef XME_MULTITHREAD

    XME_ASSERT(portId < inputPortCount);

#ifdef XME_MULTITHREAD
    XME_ASSERT(inputPortAccessed != XME_HAL_TLS_INVALID_TLS_HANDLE);
    accessed = (char*) xme_hal_tls_get(inputPortAccessed);
    XME_ASSERT(NULL != accessed);

    // We need to complete the read operation if the port has been accessed
    if (accessed[portId / 8U] & (1 << (portId % 8U)))
#else // #ifdef XME_MULTITHREAD
    if (inputPorts[portId].state.locked)
#endif // #ifdef XME_MULTITHREAD
    {
        status = xme_core_dataHandler_completeReadOperation(inputPorts[portId].dataPacketId);
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "[monitorMBComponentWrapper] CompleteReadOperation for port (interalPortId: %d, dataPacketId: %d) returned error code %d.\n",
            portId, inputPorts[portId].dataPacketId, status
        );

#ifdef XME_MULTITHREAD
        accessed[portId / 8U] &= ~(1 << (portId % 8U));
#endif // #ifdef XME_MULTITHREAD
        inputPorts[portId].state.dataValid = 0;
        inputPorts[portId].state.attributesValid = 0;
        inputPorts[portId].state.locked = 0;
        inputPorts[portId].state.error = 0;
    }

    return status;
}

