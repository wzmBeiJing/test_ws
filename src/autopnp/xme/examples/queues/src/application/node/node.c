/*
 * Copyright (c) 2011-2014, fortiss GmbH.
 * Licensed under the Apache License, Version 2.0.
 *
 * Use, modification and distribution are subject to the terms specified
 * in the accompanying license file LICENSE.txt located at the root directory
 * of this software distribution. A copy is available at
 * http://chromosome.fortiss.org/.
 *
 * This file is part of CHROMOSOME.
 *
 * $Id: node.c 7805 2014-03-13 09:54:35Z geisinger $
 */

/**
 * \file
 *         Main file of node 'node'.
 *
 * \author
 *         This file has been generated by the CHROMOSOME Modeling Tool (XMT)
 *         (fortiss GmbH).
 */

/******************************************************************************/
/***   Includes                                                             ***/
/******************************************************************************/
#include "queues/adv/receiver/include/receiveFunction.h"
#include "queues/adv/receiver/include/receiveFunctionWrapper.h"
#include "queues/adv/receiver/include/receiverComponent.h"
#include "queues/adv/receiver/include/receiverComponentWrapper.h"
#include "queues/adv/receiver/include/receiverManifest.h"
#include "queues/adv/sender/include/sendFunction.h"
#include "queues/adv/sender/include/sendFunctionWrapper.h"
#include "queues/adv/sender/include/senderComponent.h"
#include "queues/adv/sender/include/senderComponentWrapper.h"
#include "queues/adv/sender/include/senderManifest.h"
#include "queues/topic/dictionary.h"
#include "queues/topic/dictionaryData.h"
#include "xme/core/broker/include/broker.h"
#include "xme/core/broker/include/brokerPnpManagerInterface.h"
#include "xme/core/dataHandler/include/dataHandlerConfigurator.h"
#include "xme/core/directory/include/topicRegistry.h"
#include "xme/core/executionManager/include/executionManagerScheduleManagementInterface.h"
#include "xme/core/logUtils.h"
#include "xme/core/manifestRepository/include/manifestRepository.h"
#include "xme/core/node.h"
#include "xme/core/nodeManager/include/componentRepository.h"
#include "xme/core/nodeManager/include/componentRepositoryBuilder.h"
#include "xme/core/nodeManager/include/componentRepositoryPnpClientInterface.h"
#include "xme/core/topic.h"
#include "xme/core/topicData.h"
#include "xme/hal/include/cmdLine.h"
#include "xme/hal/include/context.h"
#include "xme/hal/include/env.h"
#include "xme/hal/include/mem.h"
#include "xme/hal/include/net.h"
#include "xme/hal/include/sched.h"
#include "xme/hal/include/sharedPtr.h"
#include "xme/hal/include/sync.h"
#include "xme/hal/include/time.h"
#include "xme/hal/include/tls.h"
#include "xme/wp/channel/include/channelInjector.h"
#include "xme/wp/channel/include/channelInjectorWayPointFunctionWrapper.h"
#include "xme/wp/channel/include/channelSelector.h"
#include "xme/wp/channel/include/channelSelectorWayPointFunctionWrapper.h"
#include "xme/wp/marshal/include-gen/demarshaler.h"
#include "xme/wp/marshal/include-gen/demarshalerFunctionWrapper.h"
#include "xme/wp/marshal/include-gen/marshaler.h"
#include "xme/wp/marshal/include-gen/marshalerFunctionWrapper.h"
#include "xme/wp/marshal/include/demarshaler.h"
#include "xme/wp/marshal/include/marshaler.h"
#include "xme/wp/udp/include/udpReceive.h"
#include "xme/wp/udp/include/udpReceiveWayPointFunctionWrapper.h"
#include "xme/wp/udp/include/udpSend.h"
#include "xme/wp/udp/include/udpSendWayPointFunctionWrapper.h"

#include <inttypes.h>

// PROTECTED REGION ID(NODE_INCLUDES) ENABLED START

// PROTECTED REGION END

/******************************************************************************/
/***   Variables                                                            ***/
/******************************************************************************/
/**
 * \brief Array of all ports on this node.
 *
 * \details Index | Port
 *              0 | receiver.in
 *              1 | sender.out
 */
static xme_core_dataManager_dataPacketId_t ports[2];

static xme_core_exec_functionDescriptor_t* receiverFuncDescs[1] = {NULL};
static xme_core_exec_functionDescriptor_t* sender1FuncDescs[1] = {NULL};
static xme_core_exec_functionDescriptor_t* sender2FuncDescs[1] = {NULL};


/******************************************************************************/
/***   Prototypes                                                           ***/
/******************************************************************************/
XME_EXTERN_C_BEGIN

/**
 * \brief Initialize CHROMOSOME HAL and core components.
 *
 * \param[in] argc Number of command line arguments.
 * \param[in] argv Command line argument vector.
 *
 * \retval XME_STATUS_SUCCESS when initialization succeeded without problems.
 * \retval XME_STATUS_OUT_OF_RESOURCES when an error occured during initialization
 *         of one of the HAL or core components.
 */
xme_status_t
xmeInit
(
    int argc,
    char* argv[]
);

/**
 * \brief Finalize CHROMOSOME hal and core components.
 */
void
xmeFini(void);

/**
 * \brief Configures and activates the initial schedule for this node.
 */
void
configureSchedule(void);

/**
 * \brief Get the data packet ID of the given port. Can be used after createComponentInstances has been called.
 *
 * \param[in] componentID ID of the component to which the port belongs.
 * \param[in] portIndex Index of the port.
 *
 * \return The data packet ID of the port.
 */
xme_core_dataManager_dataPacketId_t
getDataPacketID
(
    xme_core_component_t componentID,
    uint16_t portIndex
);

/**
 * \brief Get a pointer to the function descriptor of the given function.
 *
 * \param[in] componentID ID of the component to which the function belongs.
 * \param[in] functionIndex Index of the function.
 *
 * \return The pointer to the function descriptor.
 */
xme_core_exec_functionDescriptor_t*
getFunctionDescriptor
(
    xme_core_component_t componentID,
    uint16_t functionIndex
);

/**
 * \brief Creates all component instances.
 *
 * \return XME_STATUS_SUCCESS if operation was successful.
 *         Ony any error we will shut down.
 */
xme_status_t
createComponentInstances(void);

/**
 * \brief Creates all waypoints and their configurations.
 */
void
createWaypoints(void);

/**
 * \brief Register attribute descriptor lists topic data sizes
 *        for each topic.
 *
 * \details This step is required before creating any ports that want to use
 *          attributes.
 *
 * \return XME_STATUS_SUCCESS if registration was successful, otherwise an
 *         error code.
 */
xme_status_t
registerTopicsAndAttributes(void);

/**
 * \brief Create and add manifests to manfiest repository for all known components types.
 */
void
createComponentTypeManifests(void);

/**
 * \brief Register all known components types in the logging system.
 */
void
registerComponentTypesInLoggingEngine(void);

/**
 * \brief Create channel injector waypoint instance.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param descriptor Will be set to a pointer to the allocation function descriptor.
 * \param componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
createChannelInjectorWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
);

/**
 * \brief Adds a configuration entry to the channel injector waypoint.
 *
 * \details Creates and adds configuration structure for channel injector waypoint.
 *          The required port and buffer are also created.
 *
 * \param descriptor Function descriptor of this waypoint configuration.
 * \param inputPort Pointer to port id that will be used for the input of the configuration.
 * \param inputPortQueueSize Queue size of the input port.
 * \param outputPort Pointer to port id that will be used for the output port of the configuration.
 * \param injectedChannelID the channel identificator.
 * \param topic Topic for this configuration.
 * \param sizeOfTopic Size of the topic data structure.
 * \param instanceId See instanceId parameter of xme_wp_channel_channelInjector_addConfig.
 * \param recvBuffer See buffer parameter of xme_wp_channel_channelInjector_addConfig.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
channelInjectorWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputPort,
    uint8_t inputPortQueueSize,
    xme_core_dataManager_dataPacketId_t* outputPort,
    xme_core_channelId_t injectedChannelID,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void** recvBuffer
);

/**
 * \brief Removes a configuration entry from the channel injector waypoint.
 *
 * \param descriptor See parameter with the same name in channelInjectorWaypointAddConfig.
 * \param instanceId See parameter with the same name in channelInjectorWaypointAddConfig.
 * \param inputPort See parameter with the same name in channelInjectorWaypointAddConfig.
 * \param outputPort See parameter with the same name in channelInjectorWaypointAddConfig.
 * \param recvBuffer See parameter with the same name in channelInjectorWaypointAddConfig.
 *
 * \retval XME_STATUS_SUCCESS always.
 */
xme_status_t
channelInjectorWaypointRemoveConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_wp_waypoint_instanceId_t instanceId,
    xme_core_dataManager_dataPacketId_t* inputPort,
    xme_core_dataManager_dataPacketId_t* outputPort,
    void* recvBuffer
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
destroyChannelInjectorWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
);
/**
 * \brief Create channel selector waypoint instance.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param descriptor Will be set to a pointer to the allocation function descriptor.
 * \param componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
createChannelSelectorWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
);

/**
 * \brief Adds a configuration entry to the channel selector waypoint.
 *
 * \details Creates and adds configuration structure for channel selector waypoint.
 *          The required port and buffer are also created.
 *
 * \param descriptor Function descriptor of this waypoint.
 * \param instanceId See instanceId parameter of xme_wp_channel_channelSelector_addConfig.
 * \param topic Topic for this configuration.
 * \param sizeOfTopic Size of the topic data structure.
 * \param inputPort Pointer to port id that will be used for the created input port of the configuration.
 * \param inputPortQueueSize Queue size of the input port.
 * \param outputPort Pointer to port id that will be used for the created output port of the configuration.
 * \param sourceChannelID the source channel identificator.
 * \param destinationChannelID the destination channel identificator.
 * \param recvBuffer See buffer parameter of xme_wp_channel_channelSelector_addConfig.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
channelSelectorWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_dataManager_dataPacketId_t* inputPort,
    uint8_t inputPortQueueSize,
    xme_core_dataManager_dataPacketId_t* outputPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_core_channelId_t sourceChannelID,
    xme_core_channelId_t destinationChannelID,
    void** recvBuffer
);

/**
 * \brief Removes a configuration entry from the channel selector waypoint.
 *
 * \param descriptor See parameter with the same name in channelSelectorWaypointAddConfig.
 * \param instanceId See parameter with the same name in channelSelectorWaypointAddConfig.
 * \param inputPort See parameter with the same name in channelSelectorWaypointAddConfig.
 * \param outputPort See parameter with the same name in channelSelectorWaypointAddConfig.
 * \param topic See parameter with the same name in channelSelectorWaypointAddConfig.
 * \param sourceChannelID See parameter with the same name in channelSelectorWaypointAddConfig.
 * \param destinationChannelID See parameter with the same name in channelSelectorWaypointAddConfig.
 * \param recvBuffer See parameter with the same name in channelSelectorWaypointAddConfig.
 *
 * \retval XME_STATUS_SUCCESS always.
 */
xme_status_t
channelSelectorWaypointRemoveConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_wp_waypoint_instanceId_t instanceId,
    xme_core_dataManager_dataPacketId_t* inputPort,
    xme_core_dataManager_dataPacketId_t* outputPort,
    xme_core_topic_t topic,
    xme_core_channelId_t sourceChannelID,
    xme_core_channelId_t destinationChannelID,
    void* recvBuffer
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
destroyChannelSelectorWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
);
/**
 * \brief Create marshaler waypoint instance.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param descriptor Will be set to a pointer to the allocation function descriptor.
 * \param componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
createMarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
);

/**
 * \brief Adds a configuration entry to the marshaler waypoint.
 *
 * \details Creates and adds a configuration entry for the marshaler waypoint.
 *          The required ports are also created.
 *
 * \param descriptor Function descriptor of this waypoint.
 * \param inputDataPort Pointer to port id that will be used for the created input port of the configuration.
 * \param inputPortQueueSize Queue size of the input port.
 * \param outputDataPort Pointer to port id that will be used for the created output port of the configuration.
 * \param instanceId Pointer where instanceId of created configuration will be written to.
 * \param topic Topic for this configuration.
 * \param sizeOfTopic Size of the topic data structure.
 * \param channelID Channel ID of the configuration.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
marshalerWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    uint8_t inputPortQueueSize,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_core_channelId_t channelID
);

/**
 * \brief Removes a configuration entry from the marshaler waypoint.
 *
 * \param descriptor See parameter with the same name in marshalerWaypointAddConfig.
 * \param inputDataPort See parameter with the same name in marshalerWaypointAddConfig.
 * \param outputDataPort See parameter with the same name in marshalerWaypointAddConfig.
 * \param instanceId See parameter with the same name in marshalerWaypointAddConfig.
 *
 * \retval XME_STATUS_SUCCESS always.
 */
xme_status_t
marshalerWaypointRemoveConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t instanceId
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
destroyMarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
);
/**
 * \brief Create demarshaler waypoint instance.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param descriptor Will be set to a pointer to the allocation function descriptor.
 * \param componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
createDemarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
);

/**
 * \brief Adds a configuration entry to the demarshaler waypoint.
 *
 * \details Creates and adds a configuration entry for the demarshaler waypoint.
 *          The required ports are also created.
 *
 * \param descriptor Function descriptor of this waypoint.
 * \param inputDataPort Pointer to port id that will be used for the created input port of the configuration.
 * \param inputPortQueueSize Queue size of the input port.
 * \param outputDataPort Pointer to port id that will be used for the created output port of the configuration.
 * \param instanceId Pointer where instanceId of created configuration will be written to.
 * \param topic Topic for this configuration.
 * \param sizeOfTopic Size of the topic data structure.
 * \param channelID Channel ID of the configuration.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
demarshalerWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    uint8_t inputPortQueueSize,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_core_channelId_t channelID
);

/**
 * \brief Removes a configuration entry from the demarshaler waypoint.
 *
 * \param descriptor See parameter with the same name in demarshalerWaypointAddConfig.
 * \param inputDataPort See parameter with the same name in demarshalerWaypointAddConfig.
 * \param outputDataPort See parameter with the same name in demarshalerWaypointAddConfig.
 * \param instanceId See parameter with the same name in demarshalerWaypointAddConfig.
 *
 * \retval XME_STATUS_SUCCESS always.
 */
xme_status_t
demarshalerWaypointRemoveConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t instanceId
);

/**
 * \brief Free resources allocated by this waypoint.
 */
void
destroyDemarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
);
/**
 * \brief  Create udp send waypoint instance.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param descriptor Will be set to a pointer to the allocation function descriptor.
 * \param componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
createUdpSendWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
);

/**
 * \brief Adds a configuration entry to the udp send waypoint.
 *
 * \details Creates and adds configuration structure for udp send waypoint.
 *          The required port and buffer are also created.
 *
 * \param descriptor Function descriptor of this waypoint.
 * \param dataPort Pointer to port id that will be used for the created port of the configuration.
 * \param key See key parameter of xme_wp_udp_udpSend_addConfig.
 * \param destIP See hostname parameter of xme_wp_udp_udpSend_addConfig.
 * \param ipPort See port parameter of xme_wp_udp_udpSend_addConfig.
 * \param topic Topic for this configuration.
 * \param sizeOfTopic Size of the topic data structure.
 * \param instanceId See instanceId parameter of xme_wp_udp_udpSend_addConfig.
 * \param sendBuffer See buffer parameter of xme_wp_udp_udpSend_addConfig.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
udpSendWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    const char* destIP,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void** sendBuffer,
    bool isBroadcast
);

/**
 * \brief Removes a configuration entry from the udp send waypoint.
 *
 * \param descriptor See parameter with the same name in udpSendWaypointAddConfig.
 * \param dataPort See parameter with the same name in udpSendWaypointAddConfig.
 * \param instanceId See parameter with the same name in udpSendWaypointAddConfig.
 * \param sendBuffer See parameter with the same name in udpSendWaypointAddConfig.
 *
 * \retval XME_STATUS_SUCCESS always.
 */
xme_status_t
udpSendWaypointRemoveConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    xme_wp_waypoint_instanceId_t instanceId,
    void* sendBuffer
);

/**
 * \brief Free resources allocated by this waypoint.
 */
void
destroyUdpSendWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
);
/**
 * \brief Create udp receive waypoint instance.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param descriptor Will be set to a pointer to the allocation function descriptor.
 * \param componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
createUdpReceiveWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
);

/**
 * \brief Adds a configuration entry to the udp receive waypoint.
 *
 * \details Creates and adds configuration structure for udp receive waypoint.
 *          The required port and buffer are also created.
 *
 * \param descriptor Function descriptor of this waypoint.
 * \param dataPort Pointer to port id that will be used for the created port of the configuration.
 * \param key See key parameter of xme_wp_udp_udpReceive_addConfig.
 * \param ipPort See port parameter of xme_wp_udp_udpReceive_addConfig.
 * \param topic Topic for this configuration.
 * \param sizeOfTopic Size of the topic data structure.
 * \param instanceId See instanceId parameter of xme_wp_udp_udpReceive_addConfig.
 * \param recvBuffer See buffer parameter of xme_wp_udp_udpReceive_addConfig.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
udpReceiveWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void** recvBuffer
);

/**
 * \brief Removes a configuration entry from the udp receive waypoint.
 *
 * \param descriptor See parameter with the same name in udpReceiveWaypointAddConfig.
 * \param dataPort See parameter with the same name in udpReceiveWaypointAddConfig.
 * \param instanceId See parameter with the same name in udpReceiveWaypointAddConfig.
 * \param recvBuffer See parameter with the same name in udpReceiveWaypointAddConfig.
 *
 * \retval XME_STATUS_SUCCESS always.
 */
xme_status_t
udpReceiveWaypointRemoveConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    xme_wp_waypoint_instanceId_t instanceId,
    void* recvBuffer
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
destroyUdpReceiveWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
);
/**
 * \brief Add packet transfer entries for all ports to the broker.
 *
 * \retval XME_STATUS_SUCCESS if operation is scuccessful.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred.
 */
xme_status_t
addDataPacketTransferEntries(void);

XME_EXTERN_C_END

/******************************************************************************/
/***   Implementation                                                       ***/
/******************************************************************************/
xme_status_t
xmeInit
(
    int argc,
    char* argv[]
)
{
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_log_logUtils_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_cmdLine_init(argc, argv, "v::", 1), XME_STATUS_OUT_OF_RESOURCES);

    // Parse command line options. Do this right here to ensure that
    // the settings are applied before further processing is started.
    {
        int c;
        while (-1 != (c = xme_hal_cmdLine_getNextOption()))
        {
            switch (c)
            {
                case 'v':
                {
                    int logLevel = xme_hal_cmdLine_getIntegerOptionArgument(-3, 2, 1);
                    xme_log_severity_t severity;
                    switch (logLevel)
                    {
                        case -3:
                            severity = XME_LOG_FATAL;
                            break;
                        case -2:
                            severity = XME_LOG_ERROR;
                            break;
                        case -1:
                            severity = XME_LOG_WARNING;
                            break;
                        case 0:
                            severity = XME_LOG_NOTE;
                            break;
                        case 1:
                            severity = XME_LOG_VERBOSE;
                            break;
                        case 2:
                            severity = XME_LOG_DEBUG;
                            break;
                        default:
                            severity = XME_LOG_NOTE;
                    }
                    xme_core_log_setMinimumLogSeverityLevel(severity);
                    break;
                }

                default:
                    XME_LOG(XME_LOG_ERROR, "Unknown option '%c'!\n", c);
            }
        }
    }

    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_env_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_sync_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_sched_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_directory_attribute_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_dataHandler_init(), XME_STATUS_OUT_OF_RESOURCES);
    {
        xme_core_exec_configStruct_t configStruct = { NULL };
        XME_CHECK(XME_STATUS_SUCCESS == xme_core_exec_init(&configStruct), XME_STATUS_OUT_OF_RESOURCES);
    }
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_sharedPtr_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_tls_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_context_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_net_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_nodeMgr_compRep_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_broker_init(NULL), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_node_init(), XME_STATUS_OUT_OF_RESOURCES);

    registerComponentTypesInLoggingEngine();


    //TODO: Remove protected region when issue #3982 has been resolved!
    // PROTECTED REGION ID(NODE_XME_INIT) ENABLED START

    // PROTECTED REGION END

     // Add interface to node registry
     {
         char addressBuffer[22];
         xme_com_interface_address_t interfaceAddress;

         (void)xme_hal_safeString_strncpy(addressBuffer, "127.0.0.1:33221", sizeof(addressBuffer));

         XME_LOG
         (
             XME_LOG_NOTE,
             "Node operates on network interface address: %s\n",
             addressBuffer
         );

         xme_com_interface_ipv4StringToGenericAddress(addressBuffer, &interfaceAddress);
         xme_core_node_addInterface(interfaceAddress);
     }

    xme_core_node_setCurrentNodeId((xme_core_node_nodeId_t) 1);

    xme_core_node_setNodeName("node");

    return XME_STATUS_SUCCESS;
}

void
xmeFini(void)
{
	//TODO: Remove protected region when issue #3982 has been resolved!
    // PROTECTED REGION ID(NODE_XME_FINI) ENABLED START

    // PROTECTED REGION END

    xme_core_node_fini();
    xme_core_broker_fini();
    xme_core_nodeMgr_compRep_fini();
    xme_hal_net_fini();
    xme_hal_context_fini();
    xme_hal_tls_fini();
    xme_hal_sharedPtr_fini();
    xme_core_dataHandler_fini();
    xme_core_directory_attribute_fini();
    xme_hal_sched_fini();
    xme_hal_sync_fini();
    xme_hal_env_fini();
    xme_hal_cmdLine_fini();
    xme_core_log_logUtils_fini();
}


// Disable warning about unexpected exceptions. See issue #3848.
#if _MSC_VER && defined(__cplusplus)
    #pragma warning( push )
    #pragma warning( disable : 4297 )
#endif

void
configureSchedule(void)
{
    xme_status_t status;
    xme_core_exec_schedule_handle_t scheduleId;
    xme_core_exec_schedule_table_t* nodeSchedules[1];

    // Execution Manager and Scheduler

    // Configure dispatcher
    // Component 'receiver' function 'receive'
    if (NULL != receiverFuncDescs[0])
    {
        status = xme_core_exec_dispatcher_createFunctionExecutionUnit(receiverFuncDescs[0], true);
        XME_ASSERT_NORVAL(XME_STATUS_SUCCESS == status);
    }
    // Component 'sender1' function 'send'
    if (NULL != sender1FuncDescs[0])
    {
        status = xme_core_exec_dispatcher_createFunctionExecutionUnit(sender1FuncDescs[0], true);
        XME_ASSERT_NORVAL(XME_STATUS_SUCCESS == status);
    }
    // Component 'sender2' function 'send'
    if (NULL != sender2FuncDescs[0])
    {
        status = xme_core_exec_dispatcher_createFunctionExecutionUnit(sender2FuncDescs[0], true);
        XME_ASSERT_NORVAL(XME_STATUS_SUCCESS == status);
    }

    // Configure schedule
    xme_core_exec_scheduler_createScheduleTable
    (
        &(nodeSchedules[0]),
        xme_hal_time_timeIntervalFromSeconds(3ull)
    );

    if (NULL != sender1FuncDescs[0])
    {
        // Add function 'send' of component instance 'sender1' of type 'sender' to schedule
        status = xme_core_exec_scheduler_addElementToScheduleTable
        (
            nodeSchedules[0],
            sender1FuncDescs[0]->componentId,
            sender1FuncDescs[0]->functionId,
            sender1FuncDescs[0]->taskArgs,
            xme_hal_time_timeIntervalFromSeconds(0ull),
            xme_hal_time_timeIntervalFromMilliseconds(10ull),
            2,
            0,
            true
        );
        XME_ASSERT_NORVAL(XME_STATUS_SUCCESS == status);
    }
    if (NULL != sender2FuncDescs[0])
    {
        // Add function 'send' of component instance 'sender2' of type 'sender' to schedule
        status = xme_core_exec_scheduler_addElementToScheduleTable
        (
            nodeSchedules[0],
            sender2FuncDescs[0]->componentId,
            sender2FuncDescs[0]->functionId,
            sender2FuncDescs[0]->taskArgs,
            xme_hal_time_timeIntervalFromMilliseconds(10ull),
            xme_hal_time_timeIntervalFromMilliseconds(10ull),
            2,
            0,
            true
        );
        XME_ASSERT_NORVAL(XME_STATUS_SUCCESS == status);
    }
    if (NULL != receiverFuncDescs[0])
    {
        // Add function 'receive' of component instance 'receiver' of type 'receiver' to schedule
        status = xme_core_exec_scheduler_addElementToScheduleTable
        (
            nodeSchedules[0],
            receiverFuncDescs[0]->componentId,
            receiverFuncDescs[0]->functionId,
            receiverFuncDescs[0]->taskArgs,
            xme_hal_time_timeIntervalFromMilliseconds(20ull),
            xme_hal_time_timeIntervalFromMilliseconds(10ull),
            1,
            0,
            true
        );
        XME_ASSERT_NORVAL(XME_STATUS_SUCCESS == status);
    }

    status = xme_core_exec_scheduler_registerSchedule(nodeSchedules[0], &scheduleId);
    XME_ASSERT_NORVAL(XME_STATUS_SUCCESS == status);

    // Activate schedule
    xme_core_exec_scheduler_activateSchedule(scheduleId);
}

xme_core_dataManager_dataPacketId_t
getDataPacketID
(
    xme_core_component_t componentID,
    uint16_t portIndex
)
{
    xme_status_t status;
    xme_core_nodeMgr_compRep_componentHandle_t componentHandle;
    xme_core_nodeMgr_compRep_portHandle_t portHandle;

    status = xme_core_nodeMgr_compRep_getComponentInstance(XME_CORE_NODE_LOCAL_NODE_ID, componentID, &componentHandle);
    XME_ASSERT_RVAL(XME_STATUS_SUCCESS == status, XME_CORE_DATAMANAGER_DATAPACKETID_INVALID);

    portHandle = xme_core_nodeMgr_compRep_getPort(componentHandle, portIndex);

    return xme_core_nodeMgr_compRep_getDataPacketID(portHandle);
}

xme_core_exec_functionDescriptor_t*
getFunctionDescriptor
(
    xme_core_component_t componentID,
    uint16_t functionIndex
)
{
    xme_status_t status;
    xme_core_nodeMgr_compRep_componentHandle_t componentHandle;
    xme_core_nodeMgr_compRep_functionHandle_t functionHandle;

    status = xme_core_nodeMgr_compRep_getComponentInstance(XME_CORE_NODE_LOCAL_NODE_ID, componentID, &componentHandle);
    XME_ASSERT_RVAL(XME_STATUS_SUCCESS == status, NULL);

    functionHandle = xme_core_nodeMgr_compRep_getFunction(componentHandle, functionIndex);

    return (xme_core_exec_functionDescriptor_t*)xme_core_nodeMgr_compRep_getFunctionDescriptor(functionHandle);
}

xme_status_t
createComponentInstances(void)
{
    xme_status_t status;

    // Create statically configured component instance 'receiver' of type 'receiver'
    {
        xme_core_nodeMgr_compRep_componentBuilder_t* builder = NULL;
        xme_core_nodeMgr_compRep_componentHandle_t componentHandle;

        builder = xme_core_nodeMgr_compRep_createBuilder(XME_CORE_NODE_LOCAL_NODE_ID, (xme_core_componentType_t)4098);
        XME_CHECK_MSG(NULL != builder, XME_STATUS_INTERNAL_ERROR, XME_LOG_FATAL, "%s:%d Creation of component instance 'receiver' of type 'receiver' failed. Builder could not be created.\n", __FILE__, __LINE__);
        xme_core_nodeMgr_compRep_builderSetComponentID(builder, (xme_core_component_t)128);
        xme_core_nodeMgr_compRep_builderSetExecutionPeriod(builder, 0, xme_hal_time_timeIntervalFromSeconds(3ull)); // Function 'receive'
        status = xme_core_nodeMgr_compRep_build(builder, &componentHandle);
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_FATAL, "%s:%d Creation of component instance 'receiver' of type 'receiver' failed. Building of component failed.\n", __FILE__, __LINE__);

        status = xme_core_nodeMgr_compRep_setStateToAnnounced(componentHandle);
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_FATAL, "%s:%d Creation of component instance 'receiver' of type 'receiver' failed. Setting state to ANNOUNCED failed.\n", __FILE__, __LINE__);

        status = xme_core_nodeMgr_compRep_createAndRegisterComponent(componentHandle);
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_FATAL, "%s:%d Creation of component instance 'receiver' of type 'receiver' failed. Registration and port allocation failed.\n", __FILE__, __LINE__);

        ports[0] = getDataPacketID((xme_core_component_t)128, 0);
        
        receiverFuncDescs[0] = getFunctionDescriptor((xme_core_component_t)128, 0);
    }
    
    // Create statically configured component instance 'sender1' of type 'sender'
    {
        xme_core_nodeMgr_compRep_componentBuilder_t* builder = NULL;
        xme_core_nodeMgr_compRep_componentHandle_t componentHandle;

        builder = xme_core_nodeMgr_compRep_createBuilder(XME_CORE_NODE_LOCAL_NODE_ID, (xme_core_componentType_t)4099);
        XME_CHECK_MSG(NULL != builder, XME_STATUS_INTERNAL_ERROR, XME_LOG_FATAL, "%s:%d Creation of component instance 'sender1' of type 'sender' failed. Builder could not be created.\n", __FILE__, __LINE__);
        xme_core_nodeMgr_compRep_builderSetComponentID(builder, (xme_core_component_t)129);
        xme_core_nodeMgr_compRep_builderSetExecutionPeriod(builder, 0, xme_hal_time_timeIntervalFromSeconds(6ull)); // Function 'send'
        status = xme_core_nodeMgr_compRep_build(builder, &componentHandle);
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_FATAL, "%s:%d Creation of component instance 'sender1' of type 'sender' failed. Building of component failed.\n", __FILE__, __LINE__);

        status = xme_core_nodeMgr_compRep_setStateToAnnounced(componentHandle);
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_FATAL, "%s:%d Creation of component instance 'sender1' of type 'sender' failed. Setting state to ANNOUNCED failed.\n", __FILE__, __LINE__);

        status = xme_core_nodeMgr_compRep_createAndRegisterComponent(componentHandle);
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_FATAL, "%s:%d Creation of component instance 'sender1' of type 'sender' failed. Registration and port allocation failed.\n", __FILE__, __LINE__);

        ports[1] = getDataPacketID((xme_core_component_t)129, 0);
        
        sender1FuncDescs[0] = getFunctionDescriptor((xme_core_component_t)129, 0);
    }
    
    // Create statically configured component instance 'sender2' of type 'sender'
    {
        xme_core_nodeMgr_compRep_componentBuilder_t* builder = NULL;
        xme_core_nodeMgr_compRep_componentHandle_t componentHandle;

        builder = xme_core_nodeMgr_compRep_createBuilder(XME_CORE_NODE_LOCAL_NODE_ID, (xme_core_componentType_t)4099);
        XME_CHECK_MSG(NULL != builder, XME_STATUS_INTERNAL_ERROR, XME_LOG_FATAL, "%s:%d Creation of component instance 'sender2' of type 'sender' failed. Builder could not be created.\n", __FILE__, __LINE__);
        xme_core_nodeMgr_compRep_builderSetComponentID(builder, (xme_core_component_t)130);
        xme_core_nodeMgr_compRep_builderSetExecutionPeriod(builder, 0, xme_hal_time_timeIntervalFromSeconds(6ull)); // Function 'send'
        status = xme_core_nodeMgr_compRep_build(builder, &componentHandle);
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_FATAL, "%s:%d Creation of component instance 'sender2' of type 'sender' failed. Building of component failed.\n", __FILE__, __LINE__);

        status = xme_core_nodeMgr_compRep_setStateToAnnounced(componentHandle);
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_FATAL, "%s:%d Creation of component instance 'sender2' of type 'sender' failed. Setting state to ANNOUNCED failed.\n", __FILE__, __LINE__);

        status = xme_core_nodeMgr_compRep_createAndRegisterComponent(componentHandle);
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_FATAL, "%s:%d Creation of component instance 'sender2' of type 'sender' failed. Registration and port allocation failed.\n", __FILE__, __LINE__);

        ports[1] = getDataPacketID((xme_core_component_t)130, 0);
        
        sender2FuncDescs[0] = getFunctionDescriptor((xme_core_component_t)130, 0);
    }

    return XME_STATUS_SUCCESS;
}
void
createWaypoints(void)
{
}

xme_status_t
registerTopicsAndAttributes(void)
{
    // Register topic data size for topic 'pnpManager_runtime_graph_model'
    {
        xme_status_t status;

        status = xme_core_directory_topicRegistry_registerTopicSize
        (
            XME_CORE_TOPIC_PNPMANAGER_RUNTIME_GRAPH_MODEL,
            sizeof(xme_core_topic_pnpManager_runtime_graph_model_t),
            false
        );

        XME_CHECK(XME_STATUS_SUCCESS == status, status);
    }

    // Register attribute descriptor list for topic 'pnpManager_runtime_graph_model'
    {
        xme_status_t status;
        xme_core_attribute_descriptor_list_t attributeDescriptorList;
        xme_core_attribute_descriptor_t attributeDescriptors[1];

        // Attribute 'channelID'
        attributeDescriptors[0].key = (xme_core_attribute_key_t) XME_CORE_ATTRIBUTE_KEY_CHANNELID;
        attributeDescriptors[0].size = sizeof(uint32_t);

        attributeDescriptorList.length = 1;
        attributeDescriptorList.element = attributeDescriptors;

        status = xme_core_directory_attribute_registerAttributeDescriptorList
        (
            XME_CORE_TOPIC_PNPMANAGER_RUNTIME_GRAPH_MODEL,
            &attributeDescriptorList,
            false
        );

        if (status != XME_STATUS_SUCCESS)
        {
            XME_LOG(XME_LOG_WARNING, "Registration of attribute descriptor list for topic 'pnpManager_runtime_graph_model' failed.\n");
        }
    }
    
    // Register topic data size for topic 'login_loginRequest'
    {
        xme_status_t status;

        status = xme_core_directory_topicRegistry_registerTopicSize
        (
            XME_CORE_TOPIC_LOGIN_LOGINREQUEST,
            sizeof(xme_core_topic_login_loginRequest_t),
            false
        );

        XME_CHECK(XME_STATUS_SUCCESS == status, status);
    }

    // Register attribute descriptor list for topic 'login_loginRequest'
    {
        xme_status_t status;
        xme_core_attribute_descriptor_list_t attributeDescriptorList;
        xme_core_attribute_descriptor_t attributeDescriptors[1];

        // Attribute 'channelID'
        attributeDescriptors[0].key = (xme_core_attribute_key_t) XME_CORE_ATTRIBUTE_KEY_CHANNELID;
        attributeDescriptors[0].size = sizeof(uint32_t);

        attributeDescriptorList.length = 1;
        attributeDescriptorList.element = attributeDescriptors;

        status = xme_core_directory_attribute_registerAttributeDescriptorList
        (
            XME_CORE_TOPIC_LOGIN_LOGINREQUEST,
            &attributeDescriptorList,
            false
        );

        if (status != XME_STATUS_SUCCESS)
        {
            XME_LOG(XME_LOG_WARNING, "Registration of attribute descriptor list for topic 'login_loginRequest' failed.\n");
        }
    }
    
    // Register topic data size for topic 'login_loginResponse'
    {
        xme_status_t status;

        status = xme_core_directory_topicRegistry_registerTopicSize
        (
            XME_CORE_TOPIC_LOGIN_LOGINRESPONSE,
            sizeof(xme_core_topic_login_loginResponse_t),
            false
        );

        XME_CHECK(XME_STATUS_SUCCESS == status, status);
    }

    // Register attribute descriptor list for topic 'login_loginResponse'
    {
        xme_status_t status;
        xme_core_attribute_descriptor_list_t attributeDescriptorList;
        xme_core_attribute_descriptor_t attributeDescriptors[1];

        // Attribute 'channelID'
        attributeDescriptors[0].key = (xme_core_attribute_key_t) XME_CORE_ATTRIBUTE_KEY_CHANNELID;
        attributeDescriptors[0].size = sizeof(uint32_t);

        attributeDescriptorList.length = 1;
        attributeDescriptorList.element = attributeDescriptors;

        status = xme_core_directory_attribute_registerAttributeDescriptorList
        (
            XME_CORE_TOPIC_LOGIN_LOGINRESPONSE,
            &attributeDescriptorList,
            false
        );

        if (status != XME_STATUS_SUCCESS)
        {
            XME_LOG(XME_LOG_WARNING, "Registration of attribute descriptor list for topic 'login_loginResponse' failed.\n");
        }
    }
    
    // Register topic data size for topic 'login_pnpLoginRequest'
    {
        xme_status_t status;

        status = xme_core_directory_topicRegistry_registerTopicSize
        (
            XME_CORE_TOPIC_LOGIN_PNPLOGINREQUEST,
            sizeof(xme_core_topic_login_pnpLoginRequest_t),
            false
        );

        XME_CHECK(XME_STATUS_SUCCESS == status, status);
    }

    // Register attribute descriptor list for topic 'login_pnpLoginRequest'
    {
        xme_status_t status;
        xme_core_attribute_descriptor_list_t attributeDescriptorList;
        xme_core_attribute_descriptor_t attributeDescriptors[1];

        // Attribute 'channelID'
        attributeDescriptors[0].key = (xme_core_attribute_key_t) XME_CORE_ATTRIBUTE_KEY_CHANNELID;
        attributeDescriptors[0].size = sizeof(uint32_t);

        attributeDescriptorList.length = 1;
        attributeDescriptorList.element = attributeDescriptors;

        status = xme_core_directory_attribute_registerAttributeDescriptorList
        (
            XME_CORE_TOPIC_LOGIN_PNPLOGINREQUEST,
            &attributeDescriptorList,
            false
        );

        if (status != XME_STATUS_SUCCESS)
        {
            XME_LOG(XME_LOG_WARNING, "Registration of attribute descriptor list for topic 'login_pnpLoginRequest' failed.\n");
        }
    }
    
    // Register topic data size for topic 'login_pnpLoginResponse'
    {
        xme_status_t status;

        status = xme_core_directory_topicRegistry_registerTopicSize
        (
            XME_CORE_TOPIC_LOGIN_PNPLOGINRESPONSE,
            sizeof(xme_core_topic_login_pnpLoginResponse_t),
            false
        );

        XME_CHECK(XME_STATUS_SUCCESS == status, status);
    }

    // Register attribute descriptor list for topic 'login_pnpLoginResponse'
    {
        xme_status_t status;
        xme_core_attribute_descriptor_list_t attributeDescriptorList;
        xme_core_attribute_descriptor_t attributeDescriptors[1];

        // Attribute 'channelID'
        attributeDescriptors[0].key = (xme_core_attribute_key_t) XME_CORE_ATTRIBUTE_KEY_CHANNELID;
        attributeDescriptors[0].size = sizeof(uint32_t);

        attributeDescriptorList.length = 1;
        attributeDescriptorList.element = attributeDescriptors;

        status = xme_core_directory_attribute_registerAttributeDescriptorList
        (
            XME_CORE_TOPIC_LOGIN_PNPLOGINRESPONSE,
            &attributeDescriptorList,
            false
        );

        if (status != XME_STATUS_SUCCESS)
        {
            XME_LOG(XME_LOG_WARNING, "Registration of attribute descriptor list for topic 'login_pnpLoginResponse' failed.\n");
        }
    }
    
    // Register topic data size for topic 'login_loginAcknowledgment'
    {
        xme_status_t status;

        status = xme_core_directory_topicRegistry_registerTopicSize
        (
            XME_CORE_TOPIC_LOGIN_LOGINACKNOWLEDGMENT,
            sizeof(xme_core_topic_login_loginAcknowledgment_t),
            false
        );

        XME_CHECK(XME_STATUS_SUCCESS == status, status);
    }

    // Register attribute descriptor list for topic 'login_loginAcknowledgment'
    {
        xme_status_t status;
        xme_core_attribute_descriptor_list_t attributeDescriptorList;
        xme_core_attribute_descriptor_t attributeDescriptors[1];

        // Attribute 'channelID'
        attributeDescriptors[0].key = (xme_core_attribute_key_t) XME_CORE_ATTRIBUTE_KEY_CHANNELID;
        attributeDescriptors[0].size = sizeof(uint32_t);

        attributeDescriptorList.length = 1;
        attributeDescriptorList.element = attributeDescriptors;

        status = xme_core_directory_attribute_registerAttributeDescriptorList
        (
            XME_CORE_TOPIC_LOGIN_LOGINACKNOWLEDGMENT,
            &attributeDescriptorList,
            false
        );

        if (status != XME_STATUS_SUCCESS)
        {
            XME_LOG(XME_LOG_WARNING, "Registration of attribute descriptor list for topic 'login_loginAcknowledgment' failed.\n");
        }
    }
    
    // Register topic data size for topic 'pnp_componentInstanceManifest'
    {
        xme_status_t status;

        status = xme_core_directory_topicRegistry_registerTopicSize
        (
            XME_CORE_TOPIC_PNP_COMPONENTINSTANCEMANIFEST,
            sizeof(xme_core_topic_pnp_componentInstanceManifest_t),
            false
        );

        XME_CHECK(XME_STATUS_SUCCESS == status, status);
    }

    // Register attribute descriptor list for topic 'pnp_componentInstanceManifest'
    {
        xme_status_t status;
        xme_core_attribute_descriptor_list_t attributeDescriptorList;
        xme_core_attribute_descriptor_t attributeDescriptors[1];

        // Attribute 'channelID'
        attributeDescriptors[0].key = (xme_core_attribute_key_t) XME_CORE_ATTRIBUTE_KEY_CHANNELID;
        attributeDescriptors[0].size = sizeof(uint32_t);

        attributeDescriptorList.length = 1;
        attributeDescriptorList.element = attributeDescriptors;

        status = xme_core_directory_attribute_registerAttributeDescriptorList
        (
            XME_CORE_TOPIC_PNP_COMPONENTINSTANCEMANIFEST,
            &attributeDescriptorList,
            false
        );

        if (status != XME_STATUS_SUCCESS)
        {
            XME_LOG(XME_LOG_WARNING, "Registration of attribute descriptor list for topic 'pnp_componentInstanceManifest' failed.\n");
        }
    }
    
    // Register topic data size for topic 'pnp_logoutAcknowledgment'
    {
        xme_status_t status;

        status = xme_core_directory_topicRegistry_registerTopicSize
        (
            XME_CORE_TOPIC_PNP_LOGOUTACKNOWLEDGMENT,
            sizeof(xme_core_topic_pnp_logoutAcknowledgment_t),
            false
        );

        XME_CHECK(XME_STATUS_SUCCESS == status, status);
    }

    // Register attribute descriptor list for topic 'pnp_logoutAcknowledgment'
    {
        xme_status_t status;
        xme_core_attribute_descriptor_list_t attributeDescriptorList;
        xme_core_attribute_descriptor_t attributeDescriptors[1];

        // Attribute 'channelID'
        attributeDescriptors[0].key = (xme_core_attribute_key_t) XME_CORE_ATTRIBUTE_KEY_CHANNELID;
        attributeDescriptors[0].size = sizeof(uint32_t);

        attributeDescriptorList.length = 1;
        attributeDescriptorList.element = attributeDescriptors;

        status = xme_core_directory_attribute_registerAttributeDescriptorList
        (
            XME_CORE_TOPIC_PNP_LOGOUTACKNOWLEDGMENT,
            &attributeDescriptorList,
            false
        );

        if (status != XME_STATUS_SUCCESS)
        {
            XME_LOG(XME_LOG_WARNING, "Registration of attribute descriptor list for topic 'pnp_logoutAcknowledgment' failed.\n");
        }
    }
    
    // Register topic data size for topic 'pnp_logoutRequest'
    {
        xme_status_t status;

        status = xme_core_directory_topicRegistry_registerTopicSize
        (
            XME_CORE_TOPIC_PNP_LOGOUTREQUEST,
            sizeof(xme_core_topic_pnp_logoutRequest_t),
            false
        );

        XME_CHECK(XME_STATUS_SUCCESS == status, status);
    }

    // Register attribute descriptor list for topic 'pnp_logoutRequest'
    {
        xme_status_t status;
        xme_core_attribute_descriptor_list_t attributeDescriptorList;
        xme_core_attribute_descriptor_t attributeDescriptors[1];

        // Attribute 'channelID'
        attributeDescriptors[0].key = (xme_core_attribute_key_t) XME_CORE_ATTRIBUTE_KEY_CHANNELID;
        attributeDescriptors[0].size = sizeof(uint32_t);

        attributeDescriptorList.length = 1;
        attributeDescriptorList.element = attributeDescriptors;

        status = xme_core_directory_attribute_registerAttributeDescriptorList
        (
            XME_CORE_TOPIC_PNP_LOGOUTREQUEST,
            &attributeDescriptorList,
            false
        );

        if (status != XME_STATUS_SUCCESS)
        {
            XME_LOG(XME_LOG_WARNING, "Registration of attribute descriptor list for topic 'pnp_logoutRequest' failed.\n");
        }
    }
    
    // Register topic data size for topic 'pnp_logoutNotification'
    {
        xme_status_t status;

        status = xme_core_directory_topicRegistry_registerTopicSize
        (
            XME_CORE_TOPIC_PNP_LOGOUTNOTIFICATION,
            sizeof(xme_core_topic_pnp_logoutNotification_t),
            false
        );

        XME_CHECK(XME_STATUS_SUCCESS == status, status);
    }

    // Register attribute descriptor list for topic 'pnp_logoutNotification'
    {
        xme_status_t status;
        xme_core_attribute_descriptor_list_t attributeDescriptorList;
        xme_core_attribute_descriptor_t attributeDescriptors[1];

        // Attribute 'channelID'
        attributeDescriptors[0].key = (xme_core_attribute_key_t) XME_CORE_ATTRIBUTE_KEY_CHANNELID;
        attributeDescriptors[0].size = sizeof(uint32_t);

        attributeDescriptorList.length = 1;
        attributeDescriptorList.element = attributeDescriptors;

        status = xme_core_directory_attribute_registerAttributeDescriptorList
        (
            XME_CORE_TOPIC_PNP_LOGOUTNOTIFICATION,
            &attributeDescriptorList,
            false
        );

        if (status != XME_STATUS_SUCCESS)
        {
            XME_LOG(XME_LOG_WARNING, "Registration of attribute descriptor list for topic 'pnp_logoutNotification' failed.\n");
        }
    }
    
    // Register topic data size for topic 'pnp_removeComponentRequest'
    {
        xme_status_t status;

        status = xme_core_directory_topicRegistry_registerTopicSize
        (
            XME_CORE_TOPIC_PNP_REMOVECOMPONENTREQUEST,
            sizeof(xme_core_topic_pnp_removeComponentRequest_t),
            false
        );

        XME_CHECK(XME_STATUS_SUCCESS == status, status);
    }

    // Register attribute descriptor list for topic 'pnp_removeComponentRequest'
    {
        xme_status_t status;
        xme_core_attribute_descriptor_list_t attributeDescriptorList;
        xme_core_attribute_descriptor_t attributeDescriptors[1];

        // Attribute 'channelID'
        attributeDescriptors[0].key = (xme_core_attribute_key_t) XME_CORE_ATTRIBUTE_KEY_CHANNELID;
        attributeDescriptors[0].size = sizeof(uint32_t);

        attributeDescriptorList.length = 1;
        attributeDescriptorList.element = attributeDescriptors;

        status = xme_core_directory_attribute_registerAttributeDescriptorList
        (
            XME_CORE_TOPIC_PNP_REMOVECOMPONENTREQUEST,
            &attributeDescriptorList,
            false
        );

        if (status != XME_STATUS_SUCCESS)
        {
            XME_LOG(XME_LOG_WARNING, "Registration of attribute descriptor list for topic 'pnp_removeComponentRequest' failed.\n");
        }
    }
    
    // Register topic data size for topic 'data'
    {
        xme_status_t status;

        status = xme_core_directory_topicRegistry_registerTopicSize
        (
            QUEUES_TOPIC_DATA,
            sizeof(queues_topic_data_t),
            false
        );

        XME_CHECK(XME_STATUS_SUCCESS == status, status);
    }

    // Register attribute descriptor list for topic 'data'
    {
        xme_status_t status;
        xme_core_attribute_descriptor_list_t attributeDescriptorList;
        xme_core_attribute_descriptor_t attributeDescriptors[2];

        // Attribute 'channelID'
        attributeDescriptors[0].key = (xme_core_attribute_key_t) XME_CORE_ATTRIBUTE_KEY_CHANNELID;
        attributeDescriptors[0].size = sizeof(uint32_t);
        // Attribute 'sender'
        attributeDescriptors[1].key = (xme_core_attribute_key_t) QUEUES_ATTRIBUTE_SENDER;
        attributeDescriptors[1].size = sizeof(uint8_t);

        attributeDescriptorList.length = 2;
        attributeDescriptorList.element = attributeDescriptors;

        status = xme_core_directory_attribute_registerAttributeDescriptorList
        (
            QUEUES_TOPIC_DATA,
            &attributeDescriptorList,
            false
        );

        if (status != XME_STATUS_SUCCESS)
        {
            XME_LOG(XME_LOG_WARNING, "Registration of attribute descriptor list for topic 'data' failed.\n");
        }
    }

    return XME_STATUS_SUCCESS;
}

void
createComponentTypeManifests(void)
{
    xme_status_t status;

    // Create and add manifest for component type 'receiver' to manifest repository
    {
        xme_core_componentManifest_t componentManifest;

        status = queues_adv_receiver_manifest_createComponentTypeManifest(&componentManifest);

        if (XME_STATUS_SUCCESS != status)
        {
            XME_LOG(XME_LOG_WARNING, "Creation of component type manifest for 'receiver' failed.\n");
        }
        else
        {
            status = xme_core_manifestRepository_addComponentManifest(&componentManifest, false);

            if (XME_STATUS_SUCCESS != status)
            {
                XME_LOG(XME_LOG_WARNING, "Addtion of component type manifest to manifest repository failed for 'receiver'.\n");
            }
        }
    }
    
    // Create and add manifest for component type 'sender' to manifest repository
    {
        xme_core_componentManifest_t componentManifest;

        status = queues_adv_sender_manifest_createComponentTypeManifest(&componentManifest);

        if (XME_STATUS_SUCCESS != status)
        {
            XME_LOG(XME_LOG_WARNING, "Creation of component type manifest for 'sender' failed.\n");
        }
        else
        {
            status = xme_core_manifestRepository_addComponentManifest(&componentManifest, false);

            if (XME_STATUS_SUCCESS != status)
            {
                XME_LOG(XME_LOG_WARNING, "Addtion of component type manifest to manifest repository failed for 'sender'.\n");
            }
        }
    }
}

void
registerComponentTypesInLoggingEngine(void)
{
    xme_status_t status;

    {
        // Register component type 'receiver' in logging engine
        status = xme_core_log_registerComponent((xme_core_log_componentID_t) 4098, "receiver", xme_core_log_getMinimumLogSeverityLevel());
        XME_LOG_IF
        (
            XME_STATUS_SUCCESS != status,
            XME_LOG_WARNING,
            "Registering component with type %" PRIu32 " in logging system failed!\n",
            4098
        );
    }
    
    {
        // Register component type 'sender' in logging engine
        status = xme_core_log_registerComponent((xme_core_log_componentID_t) 4099, "sender", xme_core_log_getMinimumLogSeverityLevel());
        XME_LOG_IF
        (
            XME_STATUS_SUCCESS != status,
            XME_LOG_WARNING,
            "Registering component with type %" PRIu32 " in logging system failed!\n",
            4099
        );
    }
}


xme_status_t
createChannelInjectorWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
)
{
    static xme_core_exec_functionDescriptor_t* desc = NULL;

    if (NULL == desc)
    {
        desc = (xme_core_exec_functionDescriptor_t*)
                xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
        XME_CHECK_MSG
        (
            NULL != desc,
            XME_STATUS_OUT_OF_RESOURCES,
            XME_LOG_ERROR,
            "%s:%d Allocation of function Descriptor failed.\n",
            __FILE__,
            __LINE__
        );
        xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
        desc->task = (xme_hal_sched_taskCallback_t)
                &(xme_wp_channel_channelInjector_channelInjectorWayPointFunctionWrapper_execute);
        desc->taskArgs = desc;
        desc->componentId = componentId;
        desc->functionId = (xme_core_component_functionId_t) 1;
        desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(5ull);

        xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);

        xme_wp_channel_channelInjector_init();
    }

    *descriptor = desc;

    return XME_STATUS_SUCCESS;
}

xme_status_t
channelInjectorWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputPort,
    uint8_t inputPortQueueSize,
    xme_core_dataManager_dataPacketId_t* outputPort,
    xme_core_channelId_t injectedChannelID,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void** recvBuffer
)
{
    xme_status_t status;
    xme_core_attribute_descriptor_list_t attributeDescriptorList;

    xme_core_directory_attribute_getAttributeDescriptorList
    (
        topic,
        &attributeDescriptorList
    );

    // Create subscription port
    {
        uint8_t i = 0;
    
        status = xme_core_dataHandler_createDataPacket
        (
            sizeOfTopic,
            inputPort
        );
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of data packet failed with status %d.\n", __FILE__, __LINE__, status);
    
        status = xme_core_dataHandler_setDataPacketQueueSize(*inputPort, inputPortQueueSize);
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Setting queue size of data packet failed with status %d.\n", __FILE__, __LINE__, status);
    
        for (i = 0; i < attributeDescriptorList.length; i++)
        {
            status = xme_core_dataHandler_createAttribute
            (
                attributeDescriptorList.element[i].size,
                attributeDescriptorList.element[i].key,
                *inputPort
            );
            XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of attribute in data packet failed with status %d.\n", __FILE__, __LINE__, status);
        }
    }

    // Create publication port
    {
        uint8_t i = 0;
    
        status = xme_core_dataHandler_createDataPacket
        (
            sizeOfTopic,
            outputPort
        );
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of data packet failed with status %d.\n", __FILE__, __LINE__, status);
    
        for (i = 0; i < attributeDescriptorList.length; i++)
        {
            status = xme_core_dataHandler_createAttribute
            (
                attributeDescriptorList.element[i].size,
                attributeDescriptorList.element[i].key,
                *outputPort
            );
            XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of attribute in data packet failed with status %d.\n", __FILE__, __LINE__, status);
        }
    }

    status = xme_core_dataHandler_configure();
    XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Data handler configure call fails with status %d.\n", __FILE__, __LINE__, status);

    // Add waypoint configuration
    {
        uint16_t bufferSize;
        uint8_t i;

        bufferSize = sizeOfTopic;

        // Add enough space for each attribute
        for (i = 0; i < attributeDescriptorList.length; i++)
        {
            bufferSize += attributeDescriptorList.element[i].size;
        }

        *recvBuffer = xme_hal_mem_alloc(bufferSize);
        XME_CHECK_MSG
        (
            NULL != *recvBuffer,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Allocation of buffer failed.\n",
            __FILE__,
            __LINE__
        );

        status = xme_wp_channel_channelInjector_addConfig
        (
            instanceId,
            *inputPort,
            *outputPort,
            topic,
            sizeOfTopic,
            *recvBuffer,
            bufferSize,
            injectedChannelID
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d channelInjector addConfig failed.\n",
            __FILE__,
            __LINE__
        );
    }

    status = xme_core_broker_addDataPacketToFunction
    (
        *inputPort,
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId),
        true
    );
    XME_CHECK_MSG
    (
        XME_STATUS_SUCCESS == status,
        status,
        XME_LOG_WARNING,
        "%s:%d Addition of data packet to broker failed.\n",
        __FILE__,
        __LINE__
    );

    return XME_STATUS_SUCCESS;
}

xme_status_t
channelInjectorWaypointRemoveConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_wp_waypoint_instanceId_t instanceId,
    xme_core_dataManager_dataPacketId_t* inputPort,
    xme_core_dataManager_dataPacketId_t* outputPort,
    void* recvBuffer
)
{
    xme_status_t status;

    XME_UNUSED_PARAMETER(inputPort);
    XME_UNUSED_PARAMETER(outputPort);

    // De-Register with broker
    status = xme_core_broker_removeFunctionVariant
    (
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(instanceId)
    );
    if (XME_STATUS_SUCCESS != status)
    {
        XME_LOG
        (
            XME_LOG_WARNING,
            "%s:%d Removing the function variant from broker failed.\n",
            __FILE__,
            __LINE__
        );
    }

    // Remove waypoint configuration
    {
        xme_hal_mem_free(recvBuffer);
        recvBuffer = NULL;
        status = xme_wp_channel_channelInjector_removeConfig(instanceId);
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }

    // Destroy subscription port
    // TODO: Currently ports cannot be destroyed

    // Destroy publication port
    // TODO: Currently ports cannot be destroyed

    return XME_STATUS_SUCCESS;
}

void
destroyChannelInjectorWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
)
{
    xme_core_broker_removeFunction
    (
        descriptor->componentId,
        descriptor->functionId
    );
    xme_hal_mem_free(descriptor);
}
xme_status_t
createChannelSelectorWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
)
{
    static xme_core_exec_functionDescriptor_t* desc = NULL;

    if (NULL == desc)
    {
        desc = (xme_core_exec_functionDescriptor_t*)
                xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
        XME_CHECK_MSG
        (
            NULL != desc,
            XME_STATUS_OUT_OF_RESOURCES,
            XME_LOG_ERROR,
            "%s:%d Allocation of function Descriptor failed.\n",
            __FILE__,
            __LINE__
        );
        xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
        desc->task = (xme_hal_sched_taskCallback_t)
                &(xme_wp_channel_channelSelector_channelSelectorWayPointFunctionWrapper_execute);
        desc->taskArgs = desc;
        desc->componentId = componentId;
        desc->functionId = (xme_core_component_functionId_t) 1;
        desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(5ull);

        xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);

        xme_wp_channel_channelSelector_init();
    }

    *descriptor = desc;

    return XME_STATUS_SUCCESS;
}

xme_status_t
channelSelectorWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_dataManager_dataPacketId_t* inputPort,
    uint8_t inputPortQueueSize,
    xme_core_dataManager_dataPacketId_t* outputPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_core_channelId_t sourceChannelID,
    xme_core_channelId_t destinationChannelID,
    void** recvBuffer
)
{
    uint16_t bufferSize = 0;
    xme_status_t status;
    xme_core_attribute_descriptor_list_t attributeDescriptorList;
    bool hasConfig = false;

    // When the channel configurator already has a configuration for the given topic, then
    // we do not create a new input port, but pass XME_CORE_DATAMANAGER_DATAPACKETID_INVALID.
    // Therefore, here inputPort is set to a valid data packet ID or
    // XME_CORE_DATAMANAGER_DATAPACKETID_INVALID by hasConfig function based on the fact 
    // that if there exists a configuration or not.

    hasConfig = xme_wp_channel_channelSelector_hasConfig(topic, inputPort);

    xme_core_directory_attribute_getAttributeDescriptorList
    (
        topic,
        &attributeDescriptorList
    );

    // Create input port only, when we do not have a configuration for the given topic yet
    // (all channel mappings for the same topic share a configuration)
    if (!hasConfig)
    {
        // Create subscription port
        {
            uint8_t i = 0;
        
            status = xme_core_dataHandler_createDataPacket
            (
                sizeOfTopic,
                inputPort
            );
            XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of data packet failed with status %d.\n", __FILE__, __LINE__, status);
        
            status = xme_core_dataHandler_setDataPacketQueueSize(*inputPort, inputPortQueueSize);
            XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Setting queue size of data packet failed with status %d.\n", __FILE__, __LINE__, status);
        
            for (i = 0; i < attributeDescriptorList.length; i++)
            {
                status = xme_core_dataHandler_createAttribute
                (
                    attributeDescriptorList.element[i].size,
                    attributeDescriptorList.element[i].key,
                    *inputPort
                );
                XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of attribute in data packet failed with status %d.\n", __FILE__, __LINE__, status);
            }
        }

        // Allocate buffer
        {
            uint8_t i;

            bufferSize = sizeOfTopic;

            // Add enough space for each attribute
            for (i = 0; i < attributeDescriptorList.length; i++)
            {
                bufferSize += attributeDescriptorList.element[i].size;
            }

            *recvBuffer = xme_hal_mem_alloc(bufferSize);
            XME_CHECK_MSG
            (
                NULL != *recvBuffer,
                XME_STATUS_INTERNAL_ERROR,
                XME_LOG_ERROR,
                "%s:%d Allocation of buffer failed.\n",
                __FILE__,
                __LINE__
            );
        }
    }
    else
    {
        *recvBuffer = NULL;
    }

    // Create publication port
    {
        uint8_t i = 0;
    
        status = xme_core_dataHandler_createDataPacket
        (
            sizeOfTopic,
            outputPort
        );
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of data packet failed with status %d.\n", __FILE__, __LINE__, status);
    
        for (i = 0; i < attributeDescriptorList.length; i++)
        {
            status = xme_core_dataHandler_createAttribute
            (
                attributeDescriptorList.element[i].size,
                attributeDescriptorList.element[i].key,
                *outputPort
            );
            XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of attribute in data packet failed with status %d.\n", __FILE__, __LINE__, status);
        }
    }

    status = xme_core_dataHandler_configure();
    XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Data handler configure call fails with status %d.\n", __FILE__, __LINE__, status);

    // Add waypoint configuration
    status = xme_wp_channel_channelSelector_addConfig
    (
        instanceId,
        *inputPort,
        *outputPort,
        topic,
        sizeOfTopic,
        *recvBuffer,
        bufferSize,
        sourceChannelID,
        destinationChannelID
    );
    XME_CHECK_MSG
    (
        XME_STATUS_SUCCESS == status,
        XME_STATUS_INTERNAL_ERROR,
        XME_LOG_ERROR,
        "%s:%d channelSelector addConfig failed.\n",
        __FILE__,
        __LINE__
    );
    
    if (!hasConfig)
    {
        // Broker registration
        status = xme_core_broker_addDataPacketToFunction
        (
            *inputPort,
            descriptor->componentId,
            descriptor->functionId,
            (xme_core_component_functionVariantId_t)(*instanceId),
            true
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            status,
            XME_LOG_WARNING,
            "%s:%d Addition of data packet to broker failed.\n",
            __FILE__,
            __LINE__
        );
    }
    

    // TODO: Error recovery

    return XME_STATUS_SUCCESS;
}

xme_status_t
channelSelectorWaypointRemoveConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_wp_waypoint_instanceId_t instanceId,
    xme_core_dataManager_dataPacketId_t* inputPort,
    xme_core_dataManager_dataPacketId_t* outputPort,
    xme_core_topic_t topic,
    xme_core_channelId_t sourceChannelID,
    xme_core_channelId_t destinationChannelID,
    void* recvBuffer
)
{
    xme_status_t status;
    xme_core_dataManager_dataPacketId_t tempInputPort;

    XME_UNUSED_PARAMETER(inputPort);
    XME_UNUSED_PARAMETER(outputPort);

    // De-Register with broker
    status = xme_core_broker_removeFunctionVariant
    (
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(instanceId)
    );
    if (XME_STATUS_SUCCESS != status)
    {
        XME_LOG
        (
            XME_LOG_WARNING,
            "%s:%d Removing the function variant from broker failed.\n",
            __FILE__,
            __LINE__
        );
    }

    // Remove waypoint configuration
    {
        status = xme_wp_channel_channelSelector_removeConfig
        (
            instanceId,
            sourceChannelID,
            destinationChannelID
        );
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }

    if (!xme_wp_channel_channelSelector_hasConfig(topic, &tempInputPort))
    {
        xme_hal_mem_free(recvBuffer);
        recvBuffer = NULL;

        // Destroy subscription port
        // TODO: Currently ports cannot be destroyed
    }

    // Destroy publication port
    // TODO: Currently ports cannot be destroyed

    return XME_STATUS_SUCCESS;
}

void
destroyChannelSelectorWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
)
{
    xme_core_broker_removeFunction
    (
        descriptor->componentId,
        descriptor->functionId
    );

    xme_hal_mem_free(descriptor);

    // Destroy ports
    // TODO: Currently ports cannot be destroyed
}
xme_status_t
createMarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
)
{
    static xme_core_exec_functionDescriptor_t* desc = NULL;

    if (NULL == desc)
    {
        desc = (xme_core_exec_functionDescriptor_t*)
                xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
        XME_CHECK_MSG
        (
            NULL != desc,
            XME_STATUS_OUT_OF_RESOURCES,
            XME_LOG_ERROR,
            "%s:%d Allocation of function Descriptor failed.\n",
            __FILE__,
            __LINE__
        );
        xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
        desc->task = (xme_hal_sched_taskCallback_t)
                &(xme_wp_marshal_marshalerFunctionWrapper_execute);
        desc->taskArgs = desc;
        desc->componentId = componentId;
        desc->functionId = (xme_core_component_functionId_t) 1;
        desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(5ull);

        xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);

        xme_wp_marshal_marshaler_init();
    }

    *descriptor = desc;

    return XME_STATUS_SUCCESS;
}

xme_status_t
marshalerWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    uint8_t inputPortQueueSize,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_core_channelId_t channelID
)
{
    xme_status_t status;
    xme_core_attribute_descriptor_list_t attributeDescriptorList;

    xme_core_directory_attribute_getAttributeDescriptorList
    (
        topic,
        &attributeDescriptorList
    );

    // Create subscription port
    {
        uint8_t i = 0;
    
        status = xme_core_dataHandler_createDataPacket
        (
            sizeOfTopic,
            inputDataPort
        );
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of data packet failed with status %d.\n", __FILE__, __LINE__, status);
    
        status = xme_core_dataHandler_setDataPacketQueueSize(*inputDataPort, inputPortQueueSize);
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Setting queue size of data packet failed with status %d.\n", __FILE__, __LINE__, status);
    
        for (i = 0; i < attributeDescriptorList.length; i++)
        {
            status = xme_core_dataHandler_createAttribute
            (
                attributeDescriptorList.element[i].size,
                attributeDescriptorList.element[i].key,
                *inputDataPort
            );
            XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of attribute in data packet failed with status %d.\n", __FILE__, __LINE__, status);
        }
    }

    // Create publication port
    {
        uint8_t i = 0;
    
        status = xme_core_dataHandler_createDataPacket
        (
            sizeOfTopic,
            outputDataPort
        );
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of data packet failed with status %d.\n", __FILE__, __LINE__, status);
    
        for (i = 0; i < attributeDescriptorList.length; i++)
        {
            status = xme_core_dataHandler_createAttribute
            (
                attributeDescriptorList.element[i].size,
                attributeDescriptorList.element[i].key,
                *outputDataPort
            );
            XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of attribute in data packet failed with status %d.\n", __FILE__, __LINE__, status);
        }
    }

    status = xme_core_dataHandler_configure();
    XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Data handler configure call fails with status %d.\n", __FILE__, __LINE__, status);

    // Add waypoint configuration
    {
        xme_wp_marshal_marshaler_addConfig
        (
            instanceId,
            topic,
            channelID,
            *inputDataPort,
            *outputDataPort
        );
    }

    status = xme_core_broker_addDataPacketToFunction
    (
        *inputDataPort,
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId),
        true
    );
    XME_CHECK_MSG
    (
        XME_STATUS_SUCCESS == status,
        status,
        XME_LOG_WARNING,
        "%s:%d Addition of data packet to broker failed.\n",
        __FILE__,
        __LINE__
    );

    return XME_STATUS_SUCCESS;
}

xme_status_t
marshalerWaypointRemoveConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t instanceId
)
{
    xme_status_t status;

    XME_UNUSED_PARAMETER(inputDataPort);
    XME_UNUSED_PARAMETER(outputDataPort);

    // De-Register with broker
    status = xme_core_broker_removeFunctionVariant
    (
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(instanceId)
    );
    if (XME_STATUS_SUCCESS != status)
    {
        XME_LOG
        (
            XME_LOG_WARNING,
            "%s:%d Removing the function variant from broker failed.\n",
            __FILE__,
            __LINE__
        );
    }

    // Remove waypoint configuration
    {
        status = xme_wp_marshal_marshaler_removeConfig(instanceId);
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }

    // Destroy subscription port
    // TODO: Currently ports cannot be destroyed

    // Destroy publication port
    // TODO: Currently ports cannot be destroyed

    return XME_STATUS_SUCCESS;
}

void
destroyMarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
)
{
    xme_core_broker_removeFunction
    (
        descriptor->componentId,
        descriptor->functionId
    );
    xme_hal_mem_free(descriptor);
}

xme_status_t
createDemarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
)
{
    static xme_core_exec_functionDescriptor_t* desc = NULL;

    if (NULL == desc)
    {
        desc = (xme_core_exec_functionDescriptor_t*)
                xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
        XME_CHECK_MSG
        (
            NULL != desc,
            XME_STATUS_OUT_OF_RESOURCES,
            XME_LOG_ERROR,
            "%s:%d Allocation of function Descriptor failed.\n",
            __FILE__,
            __LINE__
        );
        xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
        desc->task = (xme_hal_sched_taskCallback_t)
                &(xme_wp_marshal_demarshalerFunctionWrapper_execute);
        desc->taskArgs = desc;
        desc->componentId = componentId;
        desc->functionId = (xme_core_component_functionId_t) 1;
        desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(5ull);

        xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);

        xme_wp_marshal_demarshaler_init();
    }

    *descriptor = desc;

    return XME_STATUS_SUCCESS;
}

xme_status_t
demarshalerWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    uint8_t inputPortQueueSize,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_core_channelId_t channelID
)
{
    xme_status_t status;
    xme_core_attribute_descriptor_list_t attributeDescriptorList;

    xme_core_directory_attribute_getAttributeDescriptorList
    (
        topic,
        &attributeDescriptorList
    );

    // Create subscription port
    {
        uint8_t i = 0;
    
        status = xme_core_dataHandler_createDataPacket
        (
            sizeOfTopic,
            inputDataPort
        );
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of data packet failed with status %d.\n", __FILE__, __LINE__, status);
    
        status = xme_core_dataHandler_setDataPacketQueueSize(*inputDataPort, inputPortQueueSize);
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Setting queue size of data packet failed with status %d.\n", __FILE__, __LINE__, status);
    
        for (i = 0; i < attributeDescriptorList.length; i++)
        {
            status = xme_core_dataHandler_createAttribute
            (
                attributeDescriptorList.element[i].size,
                attributeDescriptorList.element[i].key,
                *inputDataPort
            );
            XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of attribute in data packet failed with status %d.\n", __FILE__, __LINE__, status);
        }
    }

    // Create publication port
    {
        uint8_t i = 0;
    
        status = xme_core_dataHandler_createDataPacket
        (
            sizeOfTopic,
            outputDataPort
        );
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of data packet failed with status %d.\n", __FILE__, __LINE__, status);
    
        for (i = 0; i < attributeDescriptorList.length; i++)
        {
            status = xme_core_dataHandler_createAttribute
            (
                attributeDescriptorList.element[i].size,
                attributeDescriptorList.element[i].key,
                *outputDataPort
            );
            XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of attribute in data packet failed with status %d.\n", __FILE__, __LINE__, status);
        }
    }

    status = xme_core_dataHandler_configure();
    XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Data handler configure call fails with status %d.\n", __FILE__, __LINE__, status);

    // Add waypoint configuration
    {
        xme_wp_marshal_demarshaler_addConfig
        (
            instanceId,
            topic,
            channelID,
            *inputDataPort,
            *outputDataPort
        );
    }

    status = xme_core_broker_addDataPacketToFunction
    (
        *inputDataPort,
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId),
        true
    );
    XME_CHECK_MSG
    (
        XME_STATUS_SUCCESS == status,
        status,
        XME_LOG_WARNING,
        "%s:%d Addition of data packet to broker failed.\n",
        __FILE__,
        __LINE__
    );

    return XME_STATUS_SUCCESS;
}

xme_status_t
demarshalerWaypointRemoveConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t instanceId
)
{
    xme_status_t status;

    XME_UNUSED_PARAMETER(inputDataPort);
    XME_UNUSED_PARAMETER(outputDataPort);

    // De-Register with broker
    status = xme_core_broker_removeFunctionVariant
    (
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(instanceId)
    );
    if (XME_STATUS_SUCCESS != status)
    {
        XME_LOG
        (
            XME_LOG_WARNING,
            "%s:%d Removing the function variant from broker failed.\n",
            __FILE__,
            __LINE__
        );
    }

    // Remove waypoint configuration
    {
        status = xme_wp_marshal_demarshaler_removeConfig(instanceId);
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }

    // Destroy subscription port
    // TODO: Currently ports cannot be destroyed

    // Destroy publication port
    // TODO: Currently ports cannot be destroyed

    return XME_STATUS_SUCCESS;
}

void
destroyDemarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
)
{
    xme_core_broker_removeFunction
    (
        descriptor->componentId,
        descriptor->functionId
    );
    xme_hal_mem_free(descriptor);
}
xme_status_t
createUdpSendWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
)
{
    static xme_core_exec_functionDescriptor_t* desc = NULL;

    if (NULL == desc)
    {
        desc = (xme_core_exec_functionDescriptor_t*)
               xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
        XME_CHECK_MSG
        (
            NULL != desc,
            XME_STATUS_OUT_OF_RESOURCES,
            XME_LOG_ERROR,
            "%s:%d Allocation of function Descriptor failed.\n",
            __FILE__,
            __LINE__
        );
        xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
        desc->task = (xme_hal_sched_taskCallback_t)
                &(xme_wp_udp_udpSend_udpSendWayPointFunctionWrapper_execute);
        desc->taskArgs = desc;
        desc->componentId = componentId;
        desc->functionId = (xme_core_component_functionId_t) 1;
        desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(5ull);

        xme_wp_udp_udpSend_init();

        xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);
    }

    *descriptor = desc;

    return XME_STATUS_SUCCESS;
}

xme_status_t
udpSendWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    const char* destIP,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void** sendBuffer,
    bool isBroadcast
)
{
    xme_status_t status;
    xme_core_attribute_descriptor_list_t attributeDescriptorList;

    xme_core_directory_attribute_getAttributeDescriptorList
    (
        topic,
        &attributeDescriptorList
    );

    // Create subscription port
    {
        uint8_t i = 0;
    
        status = xme_core_dataHandler_createDataPacket
        (
            sizeOfTopic,
            dataPort
        );
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of data packet failed with status %d.\n", __FILE__, __LINE__, status);
    
        for (i = 0; i < attributeDescriptorList.length; i++)
        {
            status = xme_core_dataHandler_createAttribute
            (
                attributeDescriptorList.element[i].size,
                attributeDescriptorList.element[i].key,
                *dataPort
            );
            XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of attribute in data packet failed with status %d.\n", __FILE__, __LINE__, status);
        }
    }

    status = xme_core_dataHandler_configure();
    XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Data handler configure call fails with status %d.\n", __FILE__, __LINE__, status);

    // Add waypoint configuration
    {
        uint16_t bufferSize;
        uint8_t i;

        bufferSize = sizeOfTopic + xme_wp_udp_udpSend_getPackageOverHead();

        // Add enough space for each attribute
        for (i = 0; i < attributeDescriptorList.length; i++)
        {
            bufferSize += attributeDescriptorList.element[i].size;
        }

        *sendBuffer = xme_hal_mem_alloc(bufferSize);
        XME_CHECK_MSG
        (
            NULL != *sendBuffer,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Allocation of buffer failed.\n",
            __FILE__,
            __LINE__
        );

        status = xme_wp_udp_udpSend_addConfig
        (
            instanceId,
            *dataPort,
            topic,
            sizeOfTopic,
            *sendBuffer,
            bufferSize,
            key,
            destIP,
            ipPort,
            isBroadcast
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d udpSend addConfig failed.\n",
            __FILE__,
            __LINE__
        );
    }

    status = xme_core_broker_addDataPacketToFunction
    (
        *dataPort,
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId),
        true
    );
    XME_CHECK_MSG
    (
        XME_STATUS_SUCCESS == status,
        status,
        XME_LOG_WARNING,
        "%s:%d Addition of data packet to broker failed.\n",
        __FILE__,
        __LINE__
    );

    return XME_STATUS_SUCCESS;
}

xme_status_t
udpSendWaypointRemoveConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    xme_wp_waypoint_instanceId_t instanceId,
    void* sendBuffer
)
{
    xme_status_t status;

    XME_UNUSED_PARAMETER(dataPort);

    // De-Register with broker
    status = xme_core_broker_removeFunctionVariant
    (
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(instanceId)
    );
    if (XME_STATUS_SUCCESS != status)
    {
        XME_LOG
        (
            XME_LOG_WARNING,
            "%s:%d Removing the function variant from broker failed.\n",
            __FILE__,
            __LINE__
        );
    }

    // Remove waypoint configuration
    {
        xme_hal_mem_free(sendBuffer);
        sendBuffer = NULL;
        status = xme_wp_udp_udpSend_removeConfig(instanceId);
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }

    // Destroy subscription
    // TODO: Currently ports cannot be destroyed

    return XME_STATUS_SUCCESS;
}

void
destroyUdpSendWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
)
{
    xme_core_broker_removeFunction
    (
        descriptor->componentId,
        descriptor->functionId
    );
    xme_hal_mem_free(descriptor);
}
xme_status_t
createUdpReceiveWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
)
{
    static xme_core_exec_functionDescriptor_t* desc = NULL;

    if (NULL == desc)
    {
        desc = (xme_core_exec_functionDescriptor_t*)
                xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
        XME_CHECK_MSG
        (
            NULL != desc,
            XME_STATUS_OUT_OF_RESOURCES,
            XME_LOG_ERROR,
            "%s:%d Allocation of function Descriptor failed.\n",
            __FILE__,
            __LINE__
        );
        xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
        desc->task = (xme_hal_sched_taskCallback_t)
                &(xme_wp_udp_udpReceive_udpReceiveWayPointFunctionWrapper_execute);
        desc->taskArgs = desc;
        desc->componentId = componentId;
        desc->functionId = (xme_core_component_functionId_t) 1;
        desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(5ull);

        xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);

        xme_wp_udp_udpReceive_init();
    }

    *descriptor = desc;

    return XME_STATUS_SUCCESS;
}

xme_status_t
udpReceiveWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void** recvBuffer
)
{
    xme_status_t status;
    xme_core_attribute_descriptor_list_t attributeDescriptorList;

    xme_core_directory_attribute_getAttributeDescriptorList
    (
        topic,
        &attributeDescriptorList
    );

    // Create publication port
    {
        uint8_t i = 0;
    
        status = xme_core_dataHandler_createDataPacket
        (
            sizeOfTopic,
            dataPort
        );
        XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of data packet failed with status %d.\n", __FILE__, __LINE__, status);
    
        for (i = 0; i < attributeDescriptorList.length; i++)
        {
            status = xme_core_dataHandler_createAttribute
            (
                attributeDescriptorList.element[i].size,
                attributeDescriptorList.element[i].key,
                *dataPort
            );
            XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Creation of attribute in data packet failed with status %d.\n", __FILE__, __LINE__, status);
        }
    }

    status = xme_core_dataHandler_configure();
    XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_ERROR, "%s:%d Data handler configure call fails with status %d.\n", __FILE__, __LINE__, status);

    // Add waypoint configuration
    {
        uint16_t bufferSize;
        uint8_t i;

        bufferSize = sizeOfTopic + xme_wp_udp_udpReceive_getPackageOverHead();

        // Add enough space for each attribute
        for (i = 0; i < attributeDescriptorList.length; i++)
        {
            bufferSize += attributeDescriptorList.element[i].size;
        }

        *recvBuffer = xme_hal_mem_alloc(bufferSize);
        XME_CHECK_MSG
        (
            NULL != *recvBuffer,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Allocation of buffer failed.\n",
            __FILE__,
            __LINE__
        );

        status = xme_wp_udp_udpReceive_addConfig
        (
            instanceId,
            *dataPort,
            topic,
            sizeOfTopic,
            *recvBuffer,
            bufferSize,
            key,
            ipPort
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d udpReceive addConfig failed.\n",
            __FILE__,
            __LINE__
        );
    }

    // Register with broker
    status = xme_core_broker_registerFunction
    (
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId)
    );
    XME_CHECK_MSG
    (
        XME_STATUS_INVALID_PARAMETER != status && XME_STATUS_UNEXPECTED != status,
        status,
        XME_LOG_WARNING,
        "%s:%d Registeration with broker failed.\n",
        __FILE__,
        __LINE__
    );

    return XME_STATUS_SUCCESS;
}

xme_status_t
udpReceiveWaypointRemoveConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    xme_wp_waypoint_instanceId_t instanceId,
    void* recvBuffer
)
{
    xme_status_t status;

    XME_UNUSED_PARAMETER(dataPort);

    // De-Register with broker
    status = xme_core_broker_removeFunctionVariant
    (
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(instanceId)
    );
    if (XME_STATUS_SUCCESS != status)
    {
        XME_LOG
        (
            XME_LOG_WARNING,
            "%s:%d Removing the function variant from broker failed.\n",
            __FILE__,
            __LINE__
        );
    }

    // Remove waypoint configuration
    {
        xme_hal_mem_free(recvBuffer);
        recvBuffer = NULL;
        status = xme_wp_udp_udpReceive_removeConfig(instanceId);
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }

    // Destroy publication
    // TODO: Currently ports cannot be destroyed

    return XME_STATUS_SUCCESS;
}

void
destroyUdpReceiveWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
)
{
    xme_core_broker_removeFunction
    (
        descriptor->componentId,
        descriptor->functionId
    );
    xme_hal_mem_free(descriptor);
}

// Disable warning about unexpected exceptions. See issue #3848.
#if _MSC_VER && defined(__cplusplus)
    #pragma warning( pop )
#endif

xme_status_t
addDataPacketTransferEntries(void)
{
    xme_status_t status;

    status = xme_core_broker_addDataPacketTransferEntry(ports[1], ports[0]); // sender.out -> receiver.in
    XME_CHECK_MSG(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR, XME_LOG_FATAL, "%s:%d Call to xme_core_broker_addDataPacketTransferEntry() failed for source data packet ID %d and destination data packet ID %d with status %d.\n", __FILE__, __LINE__, ports[1], ports[0], status);

    return XME_STATUS_SUCCESS;
}

int
main(int argc, char* argv[])
{
    xme_status_t status;

    status = xmeInit(argc, argv);
    XME_CHECK_MSG
    (
        XME_STATUS_SUCCESS == status,
        status,
        XME_LOG_FATAL,
        "Error occurred during initialization of CHROMOSOME core components. Aborting execution.\n"
    );

    xme_hal_env_setConsoleTitle("node");

    createComponentTypeManifests();

    status = registerTopicsAndAttributes();
    XME_CHECK_MSG
    (
        XME_STATUS_SUCCESS == status,
        status,
        XME_LOG_FATAL,
        "Registration of topics and attributes failed. Aborting execution.\n"
    );

    // PROTECTED REGION ID(NODE_MAIN_BEFORE_COMPONENT_CREATION) ENABLED START

    // PROTECTED REGION END

    status = createComponentInstances();
    XME_CHECK(XME_STATUS_SUCCESS == status, status);

    createWaypoints();

    status = addDataPacketTransferEntries();
    XME_CHECK(XME_STATUS_SUCCESS == status, status);

    configureSchedule();

    // PROTECTED REGION ID(NODE_MAIN_RUN_BEFORE) ENABLED START

    // PROTECTED REGION END

    // Run the schedule
    xme_core_exec_run(0, false);

    // PROTECTED REGION ID(NODE_MAIN_RUN_AFTER) ENABLED START

    // PROTECTED REGION END

    xme_core_exec_fini();

    // Destroy waypoints

    XME_LOG(XME_LOG_NOTE, "Node node (nodeID %d) has shut down.\n", xme_core_node_getCurrentNodeId());

    xmeFini();

    return 0;
}
