/*
 * Copyright (c) 2011-2014, fortiss GmbH.
 * Licensed under the Apache License, Version 2.0.
 *
 * Use, modification and distribution are subject to the terms specified
 * in the accompanying license file LICENSE.txt located at the root directory
 * of this software distribution. A copy is available at
 * http://chromosome.fortiss.org/.
 *
 * This file is part of CHROMOSOME.
 *
 * $Id: demarshaler.c 7685 2014-03-05 15:21:06Z geisinger $
 */

/**
 * \file
 *
 * \brief  Waypoint that demarshals topic data.
 *
 * \author
 *         This file has been generated by the CHROMOSOME Modeling Tool (fortiss GmbH).
 */

/******************************************************************************/
/***   Includes                                                             ***/
/******************************************************************************/
#include "xme/wp/marshal/include/demarshaler.h"
#include "xme/wp/marshal/include/demarshalerInternalTypes.h"
#include "xme/wp/marshal/include-gen/demarshaler.h"

#include "configuratorExtension/topic/dictionary.h"
#include "configuratorExtension/topic/dictionaryData.h"

#include "xme/hal/include/mem.h"
#include "xme/hal/include/net.h"
#include "xme/hal/include/table.h"

#include "xme/core/dataHandler/include/dataHandler.h"
#include "xme/core/topic.h"
#include "xme/core/topicData.h"

#include "xme/wp/waypoint.h"

#include <inttypes.h>

/******************************************************************************/
/***   Variables                                                            ***/
/******************************************************************************/
/**
 * \brief  Constant array that contains all topics that are supported by this
 *         marshaler.
 */
static const xme_core_topic_t
supportedTopics[] =
{
    CONFIGURATOREXTENSION_TOPIC_DATA,
    XME_CORE_TOPIC_PNPMANAGER_RUNTIME_GRAPH_MODEL,
    XME_CORE_TOPIC_LOGIN_LOGINREQUEST,
    XME_CORE_TOPIC_LOGIN_LOGINRESPONSE,
    XME_CORE_TOPIC_LOGIN_PNPLOGINREQUEST,
    XME_CORE_TOPIC_LOGIN_PNPLOGINRESPONSE,
    XME_CORE_TOPIC_LOGIN_LOGINACKNOWLEDGMENT,
    XME_CORE_TOPIC_PNP_COMPONENTINSTANCEMANIFEST,
    XME_CORE_TOPIC_PNP_LOGOUTACKNOWLEDGMENT,
    XME_CORE_TOPIC_PNP_LOGOUTREQUEST,
    XME_CORE_TOPIC_PNP_LOGOUTNOTIFICATION,
    XME_CORE_TOPIC_PNP_REMOVECOMPONENTREQUEST
};

/******************************************************************************/
/***   Prototypes                                                           ***/
/******************************************************************************/
/**
 * \brief  Performs demarshaling on the given data.
 *
 * \param  topic      Topic of the data stored at inputPort.
 * \param  inputPort  The inputPort where the marshaled data is stored.
 * \param  outputPort The outputPort where the demarshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_UNSUPPORTED if the given topic is not supported by this marshaler.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshaling
(
    xme_core_topic_t topic,
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort
);

/**
 * \brief  Performs demarshaling for topic 'data'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForData
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    configuratorExtension_topic_data_t* topicData
);

/**
 * \brief  Performs demarshaling for topic 'pnpManager_runtime_graph_model'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForPnpManager_runtime_graph_model
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_pnpManager_runtime_graph_model_t* topicData
);

/**
 * \brief  Performs demarshaling for topic 'login_loginRequest'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForLogin_loginRequest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_login_loginRequest_t* topicData
);

/**
 * \brief  Performs demarshaling for topic 'login_loginResponse'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForLogin_loginResponse
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_login_loginResponse_t* topicData
);

/**
 * \brief  Performs demarshaling for topic 'login_pnpLoginRequest'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForLogin_pnpLoginRequest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_login_pnpLoginRequest_t* topicData
);

/**
 * \brief  Performs demarshaling for topic 'login_pnpLoginResponse'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForLogin_pnpLoginResponse
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_login_pnpLoginResponse_t* topicData
);

/**
 * \brief  Performs demarshaling for topic 'login_loginAcknowledgment'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForLogin_loginAcknowledgment
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_login_loginAcknowledgment_t* topicData
);

/**
 * \brief  Performs demarshaling for topic 'pnp_componentInstanceManifest'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForPnp_componentInstanceManifest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_pnp_componentInstanceManifest_t* topicData
);

/**
 * \brief  Performs demarshaling for topic 'pnp_logoutAcknowledgment'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForPnp_logoutAcknowledgment
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_pnp_logoutAcknowledgment_t* topicData
);

/**
 * \brief  Performs demarshaling for topic 'pnp_logoutRequest'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForPnp_logoutRequest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_pnp_logoutRequest_t* topicData
);

/**
 * \brief  Performs demarshaling for topic 'pnp_logoutNotification'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForPnp_logoutNotification
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_pnp_logoutNotification_t* topicData
);

/**
 * \brief  Performs demarshaling for topic 'pnp_removeComponentRequest'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForPnp_removeComponentRequest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_pnp_removeComponentRequest_t* topicData
);

/******************************************************************************/
/***   Implementation                                                       ***/
/******************************************************************************/
xme_status_t
xme_wp_marshal_demarshaler_run
(
    xme_wp_waypoint_instanceId_t instanceId
)
{
    xme_status_t status;
    xme_wp_marshal_demarshaler_configurationItem_t* configurationItem;

    configurationItem = XME_HAL_TABLE_ITEM_FROM_HANDLE
    (
        xme_wp_marshal_demarshaler_configurationTable,
        (xme_hal_table_rowHandle_t)instanceId
    );

    XME_CHECK
    (
        NULL != configurationItem,
        XME_STATUS_INVALID_HANDLE
    );

    // Do the marshaling for this configuration
    status = doDemarshaling
    (
        configurationItem->topic,
        configurationItem->inputPort,
        configurationItem->outputPort
    );

    XME_CHECK
    (
        XME_STATUS_SUCCESS == status,
        XME_STATUS_INTERNAL_ERROR
    );

    return XME_STATUS_SUCCESS;
}

xme_status_t
doDemarshaling
(
    xme_core_topic_t topic,
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort
)
{
    void* buffer;
    unsigned int bufferSize;
    xme_status_t status;

    XME_CHECK(XME_STATUS_SUCCESS == xme_core_dataHandler_startReadOperation(inputPort), XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_dataHandler_startWriteOperation(outputPort), XME_STATUS_INTERNAL_ERROR);

    // Switch for the correct topic
    // In the respective cases we allocate a buffer with the right size for the topic and
    // call a function that performs the read from the inputPort and the actual demarshaling
    if (CONFIGURATOREXTENSION_TOPIC_DATA == topic)
    {
        configuratorExtension_topic_data_t topicData;
        
        buffer = &topicData;
        bufferSize = sizeof(configuratorExtension_topic_data_t);
        
        status = doDemarshalingForData
        (
            inputPort,
            outputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC_PNPMANAGER_RUNTIME_GRAPH_MODEL == topic)
    {
        xme_core_topic_pnpManager_runtime_graph_model_t topicData;
        
        buffer = &topicData;
        bufferSize = sizeof(xme_core_topic_pnpManager_runtime_graph_model_t);
        
        status = doDemarshalingForPnpManager_runtime_graph_model
        (
            inputPort,
            outputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC_LOGIN_LOGINREQUEST == topic)
    {
        xme_core_topic_login_loginRequest_t topicData;
        
        buffer = &topicData;
        bufferSize = sizeof(xme_core_topic_login_loginRequest_t);
        
        status = doDemarshalingForLogin_loginRequest
        (
            inputPort,
            outputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC_LOGIN_LOGINRESPONSE == topic)
    {
        xme_core_topic_login_loginResponse_t topicData;
        
        buffer = &topicData;
        bufferSize = sizeof(xme_core_topic_login_loginResponse_t);
        
        status = doDemarshalingForLogin_loginResponse
        (
            inputPort,
            outputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC_LOGIN_PNPLOGINREQUEST == topic)
    {
        xme_core_topic_login_pnpLoginRequest_t topicData;
        
        buffer = &topicData;
        bufferSize = sizeof(xme_core_topic_login_pnpLoginRequest_t);
        
        status = doDemarshalingForLogin_pnpLoginRequest
        (
            inputPort,
            outputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC_LOGIN_PNPLOGINRESPONSE == topic)
    {
        xme_core_topic_login_pnpLoginResponse_t topicData;
        
        buffer = &topicData;
        bufferSize = sizeof(xme_core_topic_login_pnpLoginResponse_t);
        
        status = doDemarshalingForLogin_pnpLoginResponse
        (
            inputPort,
            outputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC_LOGIN_LOGINACKNOWLEDGMENT == topic)
    {
        xme_core_topic_login_loginAcknowledgment_t topicData;
        
        buffer = &topicData;
        bufferSize = sizeof(xme_core_topic_login_loginAcknowledgment_t);
        
        status = doDemarshalingForLogin_loginAcknowledgment
        (
            inputPort,
            outputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC_PNP_COMPONENTINSTANCEMANIFEST == topic)
    {
        xme_core_topic_pnp_componentInstanceManifest_t topicData;
        
        buffer = &topicData;
        bufferSize = sizeof(xme_core_topic_pnp_componentInstanceManifest_t);
        
        status = doDemarshalingForPnp_componentInstanceManifest
        (
            inputPort,
            outputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC_PNP_LOGOUTACKNOWLEDGMENT == topic)
    {
        xme_core_topic_pnp_logoutAcknowledgment_t topicData;
        
        buffer = &topicData;
        bufferSize = sizeof(xme_core_topic_pnp_logoutAcknowledgment_t);
        
        status = doDemarshalingForPnp_logoutAcknowledgment
        (
            inputPort,
            outputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC_PNP_LOGOUTREQUEST == topic)
    {
        xme_core_topic_pnp_logoutRequest_t topicData;
        
        buffer = &topicData;
        bufferSize = sizeof(xme_core_topic_pnp_logoutRequest_t);
        
        status = doDemarshalingForPnp_logoutRequest
        (
            inputPort,
            outputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC_PNP_LOGOUTNOTIFICATION == topic)
    {
        xme_core_topic_pnp_logoutNotification_t topicData;
        
        buffer = &topicData;
        bufferSize = sizeof(xme_core_topic_pnp_logoutNotification_t);
        
        status = doDemarshalingForPnp_logoutNotification
        (
            inputPort,
            outputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC_PNP_REMOVECOMPONENTREQUEST == topic)
    {
        xme_core_topic_pnp_removeComponentRequest_t topicData;
        
        buffer = &topicData;
        bufferSize = sizeof(xme_core_topic_pnp_removeComponentRequest_t);
        
        status = doDemarshalingForPnp_removeComponentRequest
        (
            inputPort,
            outputPort,
            &topicData
        );
    }
    else
    {
        XME_LOG
        (
            XME_LOG_ERROR,
            "xme_wp_marshal_demarshaler_run(): Given topic with id %" PRIu64 " is not "
            "supported by this demarshaler.",
            topic
        );
        return XME_STATUS_INTERNAL_ERROR;
    }

    XME_CHECK
    (
        XME_STATUS_SUCCESS == status,
        XME_STATUS_INTERNAL_ERROR
    );

    // Write marshaled data to outputPort
    status = xme_core_dataHandler_writeData
    (
        outputPort,
        buffer,
        bufferSize
    );

    XME_CHECK
    (
        XME_STATUS_SUCCESS == status,
        XME_STATUS_INTERNAL_ERROR
    );

    XME_CHECK(XME_STATUS_SUCCESS == xme_core_dataHandler_completeWriteOperation(outputPort), XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_dataHandler_completeReadOperation(inputPort), XME_STATUS_INTERNAL_ERROR);

    return XME_STATUS_SUCCESS;
}

xme_status_t
doDemarshalingForData
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    configuratorExtension_topic_data_t* topicData
)
{
    const uint32_t marshaledDataSize = 1;
    unsigned int bytesRead;
    uint8_t marshaledData[1];
    uint8_t* bufferPtr;
    xme_status_t status;


    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint8_t topicData->value
    {
        uint8_t hostValue;
    
        hostValue = (uint8_t)(*(uint8_t*)bufferPtr);
        topicData->value = hostValue;
        bufferPtr += 1;
    }

    // Demarshal attributes

    // uint32_t channelID
    {
        uint32_t demarshaledAttribute;
        uint8_t marshaledAttribute[4];
        uint8_t* bufferPtr;
    
        bufferPtr = marshaledAttribute;
    
        status = xme_core_dataHandler_readAttribute
        (
            inputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            marshaledAttribute,
            sizeof(marshaledAttribute),
            &bytesRead
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
        XME_CHECK(bytesRead == sizeof(marshaledAttribute), XME_STATUS_INTERNAL_ERROR);
    
        // uint32_t demarshaledAttribute
        {
            uint32_t hostValue;
        
            hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
            demarshaledAttribute = hostValue;
            bufferPtr += 4;
        }
    
        status = xme_core_dataHandler_writeAttribute
        (
            outputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            &demarshaledAttribute,
            4
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    }

    // configuratorExtension_attribute_quality_t quality
    {
        configuratorExtension_attribute_quality_t demarshaledAttribute;
        uint8_t marshaledAttribute[4];
        uint8_t* bufferPtr;
    
        bufferPtr = marshaledAttribute;
    
        status = xme_core_dataHandler_readAttribute
        (
            inputPort,
            XME_CORE_ATTRIBUTES(CONFIGURATOREXTENSION_ATTRIBUTE_QUALITY),
            marshaledAttribute,
            sizeof(marshaledAttribute),
            &bytesRead
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
        XME_CHECK(bytesRead == sizeof(marshaledAttribute), XME_STATUS_INTERNAL_ERROR);
    
        // uint32_t demarshaledAttribute
        {
            uint32_t hostValue;
        
            hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
            demarshaledAttribute = hostValue;
            bufferPtr += 4;
        }
    
        status = xme_core_dataHandler_writeAttribute
        (
            outputPort,
            XME_CORE_ATTRIBUTES(CONFIGURATOREXTENSION_ATTRIBUTE_QUALITY),
            &demarshaledAttribute,
            4
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    }

    return XME_STATUS_SUCCESS;
}

xme_status_t
doDemarshalingForPnpManager_runtime_graph_model
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_pnpManager_runtime_graph_model_t* topicData
)
{
    const uint32_t marshaledDataSize = 28208;
    unsigned int bytesRead;
    uint8_t marshaledData[28208];
    uint8_t* bufferPtr;
    xme_status_t status;


    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // enum topicData->action
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->action = hostValue;
        bufferPtr += 4;
    }
    
    // uint32_t topicData->nodeId
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = hostValue;
        bufferPtr += 4;
    }
    
    // struct topicData->vertex
    {
        uint8_t i0;
        
        for (i0 = 0; i0 < 60; i0++)
        {
            // struct topicData->vertex
            {
                // enum topicData->vertex[i0].vertexType
                {
                    uint32_t hostValue;
                
                    hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
                    topicData->vertex[i0].vertexType = hostValue;
                    bufferPtr += 4;
                }
                
                // char topicData->vertex[i0].vertexData
                {
                    uint16_t i1;
                    
                    for (i1 = 0; i1 < 256; i1++)
                    {
                        // char topicData->vertex[i0].vertexData
                        {
                            char hostValue;
                        
                            hostValue = (char)(*(uint8_t*)bufferPtr);
                            topicData->vertex[i0].vertexData[i1] = hostValue;
                            bufferPtr += sizeof(uint8_t);
                        }
                    }
                }
                
                // uint32_t topicData->vertex[i0].componentType
                {
                    uint32_t hostValue;
                
                    hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
                    topicData->vertex[i0].componentType = hostValue;
                    bufferPtr += 4;
                }
                
                // uint32_t topicData->vertex[i0].componentId
                {
                    uint32_t hostValue;
                
                    hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
                    topicData->vertex[i0].componentId = hostValue;
                    bufferPtr += 4;
                }
                
                // uint32_t topicData->vertex[i0].componentHandle
                {
                    uint32_t hostValue;
                
                    hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
                    topicData->vertex[i0].componentHandle = hostValue;
                    bufferPtr += 4;
                }
                
                // struct topicData->vertex[i0].portData
                {
                    uint8_t i1;
                    
                    for (i1 = 0; i1 < 32; i1++)
                    {
                        // struct topicData->vertex[i0].portData
                        {
                            // uint8_t topicData->vertex[i0].portData[i1].queueSize
                            {
                                uint8_t hostValue;
                            
                                hostValue = (uint8_t)(*(uint8_t*)bufferPtr);
                                topicData->vertex[i0].portData[i1].queueSize = hostValue;
                                bufferPtr += 1;
                            }
                        }
                    }
                }
                
                // struct topicData->vertex[i0].functionData
                {
                    uint8_t i1;
                    
                    for (i1 = 0; i1 < 16; i1++)
                    {
                        // struct topicData->vertex[i0].functionData
                        {
                            // uint64_t topicData->vertex[i0].functionData[i1].executionPeriod
                            {
                                uint64_t hostValue;
                            
                                hostValue = (uint64_t)xme_hal_net_ntohll((*(uint64_t*)bufferPtr));
                                topicData->vertex[i0].functionData[i1].executionPeriod = hostValue;
                                bufferPtr += 8;
                            }
                        }
                    }
                }
            }
        }
    }
    
    // struct topicData->edge
    {
        uint8_t i0;
        
        for (i0 = 0; i0 < 60; i0++)
        {
            // struct topicData->edge
            {
                // uint8_t topicData->edge[i0].srcVertexIndex
                {
                    uint8_t hostValue;
                
                    hostValue = (uint8_t)(*(uint8_t*)bufferPtr);
                    topicData->edge[i0].srcVertexIndex = hostValue;
                    bufferPtr += 1;
                }
                
                // uint8_t topicData->edge[i0].sinkVertexIndex
                {
                    uint8_t hostValue;
                
                    hostValue = (uint8_t)(*(uint8_t*)bufferPtr);
                    topicData->edge[i0].sinkVertexIndex = hostValue;
                    bufferPtr += 1;
                }
                
                // enum topicData->edge[i0].edgeType
                {
                    uint32_t hostValue;
                
                    hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
                    topicData->edge[i0].edgeType = hostValue;
                    bufferPtr += 4;
                }
                
                // char topicData->edge[i0].edgeData
                {
                    uint8_t i1;
                    
                    for (i1 = 0; i1 < 32; i1++)
                    {
                        // char topicData->edge[i0].edgeData
                        {
                            char hostValue;
                        
                            hostValue = (char)(*(uint8_t*)bufferPtr);
                            topicData->edge[i0].edgeData[i1] = hostValue;
                            bufferPtr += sizeof(uint8_t);
                        }
                    }
                }
            }
        }
    }

    // Demarshal attributes

    // uint32_t channelID
    {
        uint32_t demarshaledAttribute;
        uint8_t marshaledAttribute[4];
        uint8_t* bufferPtr;
    
        bufferPtr = marshaledAttribute;
    
        status = xme_core_dataHandler_readAttribute
        (
            inputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            marshaledAttribute,
            sizeof(marshaledAttribute),
            &bytesRead
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
        XME_CHECK(bytesRead == sizeof(marshaledAttribute), XME_STATUS_INTERNAL_ERROR);
    
        // uint32_t demarshaledAttribute
        {
            uint32_t hostValue;
        
            hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
            demarshaledAttribute = hostValue;
            bufferPtr += 4;
        }
    
        status = xme_core_dataHandler_writeAttribute
        (
            outputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            &demarshaledAttribute,
            4
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    }

    return XME_STATUS_SUCCESS;
}

xme_status_t
doDemarshalingForLogin_loginRequest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_login_loginRequest_t* topicData
)
{
    const uint32_t marshaledDataSize = 274;
    unsigned int bytesRead;
    uint8_t marshaledData[274];
    uint8_t* bufferPtr;
    xme_status_t status;


    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint64_t topicData->guid
    {
        uint64_t hostValue;
    
        hostValue = (uint64_t)xme_hal_net_ntohll((*(uint64_t*)bufferPtr));
        topicData->guid = hostValue;
        bufferPtr += 8;
    }
    
    // uint32_t topicData->nodeId
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = hostValue;
        bufferPtr += 4;
    }
    
    // char topicData->nodeName
    {
        uint16_t i0;
        
        for (i0 = 0; i0 < 256; i0++)
        {
            // char topicData->nodeName
            {
                char hostValue;
            
                hostValue = (char)(*(uint8_t*)bufferPtr);
                topicData->nodeName[i0] = hostValue;
                bufferPtr += sizeof(uint8_t);
            }
        }
    }
    
    // uint32_t topicData->ipAddress
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->ipAddress = hostValue;
        bufferPtr += 4;
    }
    
    // uint16_t topicData->portAddress
    {
        uint16_t hostValue;
    
        hostValue = (uint16_t)xme_hal_net_ntohs((*(uint16_t*)bufferPtr));
        topicData->portAddress = hostValue;
        bufferPtr += 2;
    }

    // Demarshal attributes

    // uint32_t channelID
    {
        uint32_t demarshaledAttribute;
        uint8_t marshaledAttribute[4];
        uint8_t* bufferPtr;
    
        bufferPtr = marshaledAttribute;
    
        status = xme_core_dataHandler_readAttribute
        (
            inputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            marshaledAttribute,
            sizeof(marshaledAttribute),
            &bytesRead
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
        XME_CHECK(bytesRead == sizeof(marshaledAttribute), XME_STATUS_INTERNAL_ERROR);
    
        // uint32_t demarshaledAttribute
        {
            uint32_t hostValue;
        
            hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
            demarshaledAttribute = hostValue;
            bufferPtr += 4;
        }
    
        status = xme_core_dataHandler_writeAttribute
        (
            outputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            &demarshaledAttribute,
            4
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    }

    return XME_STATUS_SUCCESS;
}

xme_status_t
doDemarshalingForLogin_loginResponse
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_login_loginResponse_t* topicData
)
{
    const uint32_t marshaledDataSize = 26;
    unsigned int bytesRead;
    uint8_t marshaledData[26];
    uint8_t* bufferPtr;
    xme_status_t status;


    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // enum topicData->loginStatus
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->loginStatus = hostValue;
        bufferPtr += 4;
    }
    
    // uint64_t topicData->guid
    {
        uint64_t hostValue;
    
        hostValue = (uint64_t)xme_hal_net_ntohll((*(uint64_t*)bufferPtr));
        topicData->guid = hostValue;
        bufferPtr += 8;
    }
    
    // uint32_t topicData->nodeId
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = hostValue;
        bufferPtr += 4;
    }
    
    // uint32_t topicData->channelID
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->channelID = hostValue;
        bufferPtr += 4;
    }
    
    // uint32_t topicData->ipAddress
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->ipAddress = hostValue;
        bufferPtr += 4;
    }
    
    // uint16_t topicData->portAddress
    {
        uint16_t hostValue;
    
        hostValue = (uint16_t)xme_hal_net_ntohs((*(uint16_t*)bufferPtr));
        topicData->portAddress = hostValue;
        bufferPtr += 2;
    }

    // Demarshal attributes

    // uint32_t channelID
    {
        uint32_t demarshaledAttribute;
        uint8_t marshaledAttribute[4];
        uint8_t* bufferPtr;
    
        bufferPtr = marshaledAttribute;
    
        status = xme_core_dataHandler_readAttribute
        (
            inputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            marshaledAttribute,
            sizeof(marshaledAttribute),
            &bytesRead
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
        XME_CHECK(bytesRead == sizeof(marshaledAttribute), XME_STATUS_INTERNAL_ERROR);
    
        // uint32_t demarshaledAttribute
        {
            uint32_t hostValue;
        
            hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
            demarshaledAttribute = hostValue;
            bufferPtr += 4;
        }
    
        status = xme_core_dataHandler_writeAttribute
        (
            outputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            &demarshaledAttribute,
            4
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    }

    return XME_STATUS_SUCCESS;
}

xme_status_t
doDemarshalingForLogin_pnpLoginRequest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_login_pnpLoginRequest_t* topicData
)
{
    const uint32_t marshaledDataSize = 10;
    unsigned int bytesRead;
    uint8_t marshaledData[10];
    uint8_t* bufferPtr;
    xme_status_t status;


    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint32_t topicData->nodeId
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = hostValue;
        bufferPtr += 4;
    }
    
    // uint32_t topicData->ipAddress
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->ipAddress = hostValue;
        bufferPtr += 4;
    }
    
    // uint16_t topicData->portAddress
    {
        uint16_t hostValue;
    
        hostValue = (uint16_t)xme_hal_net_ntohs((*(uint16_t*)bufferPtr));
        topicData->portAddress = hostValue;
        bufferPtr += 2;
    }

    // Demarshal attributes

    // uint32_t channelID
    {
        uint32_t demarshaledAttribute;
        uint8_t marshaledAttribute[4];
        uint8_t* bufferPtr;
    
        bufferPtr = marshaledAttribute;
    
        status = xme_core_dataHandler_readAttribute
        (
            inputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            marshaledAttribute,
            sizeof(marshaledAttribute),
            &bytesRead
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
        XME_CHECK(bytesRead == sizeof(marshaledAttribute), XME_STATUS_INTERNAL_ERROR);
    
        // uint32_t demarshaledAttribute
        {
            uint32_t hostValue;
        
            hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
            demarshaledAttribute = hostValue;
            bufferPtr += 4;
        }
    
        status = xme_core_dataHandler_writeAttribute
        (
            outputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            &demarshaledAttribute,
            4
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    }

    return XME_STATUS_SUCCESS;
}

xme_status_t
doDemarshalingForLogin_pnpLoginResponse
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_login_pnpLoginResponse_t* topicData
)
{
    const uint32_t marshaledDataSize = 14;
    unsigned int bytesRead;
    uint8_t marshaledData[14];
    uint8_t* bufferPtr;
    xme_status_t status;


    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint32_t topicData->nodeId
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = hostValue;
        bufferPtr += 4;
    }
    
    // uint32_t topicData->channelID
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->channelID = hostValue;
        bufferPtr += 4;
    }
    
    // uint32_t topicData->ipAddress
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->ipAddress = hostValue;
        bufferPtr += 4;
    }
    
    // uint16_t topicData->portAddress
    {
        uint16_t hostValue;
    
        hostValue = (uint16_t)xme_hal_net_ntohs((*(uint16_t*)bufferPtr));
        topicData->portAddress = hostValue;
        bufferPtr += 2;
    }

    // Demarshal attributes

    // uint32_t channelID
    {
        uint32_t demarshaledAttribute;
        uint8_t marshaledAttribute[4];
        uint8_t* bufferPtr;
    
        bufferPtr = marshaledAttribute;
    
        status = xme_core_dataHandler_readAttribute
        (
            inputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            marshaledAttribute,
            sizeof(marshaledAttribute),
            &bytesRead
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
        XME_CHECK(bytesRead == sizeof(marshaledAttribute), XME_STATUS_INTERNAL_ERROR);
    
        // uint32_t demarshaledAttribute
        {
            uint32_t hostValue;
        
            hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
            demarshaledAttribute = hostValue;
            bufferPtr += 4;
        }
    
        status = xme_core_dataHandler_writeAttribute
        (
            outputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            &demarshaledAttribute,
            4
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    }

    return XME_STATUS_SUCCESS;
}

xme_status_t
doDemarshalingForLogin_loginAcknowledgment
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_login_loginAcknowledgment_t* topicData
)
{
    const uint32_t marshaledDataSize = 4;
    unsigned int bytesRead;
    uint8_t marshaledData[4];
    uint8_t* bufferPtr;
    xme_status_t status;


    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint32_t topicData->nodeId
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = hostValue;
        bufferPtr += 4;
    }

    // Demarshal attributes

    // uint32_t channelID
    {
        uint32_t demarshaledAttribute;
        uint8_t marshaledAttribute[4];
        uint8_t* bufferPtr;
    
        bufferPtr = marshaledAttribute;
    
        status = xme_core_dataHandler_readAttribute
        (
            inputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            marshaledAttribute,
            sizeof(marshaledAttribute),
            &bytesRead
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
        XME_CHECK(bytesRead == sizeof(marshaledAttribute), XME_STATUS_INTERNAL_ERROR);
    
        // uint32_t demarshaledAttribute
        {
            uint32_t hostValue;
        
            hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
            demarshaledAttribute = hostValue;
            bufferPtr += 4;
        }
    
        status = xme_core_dataHandler_writeAttribute
        (
            outputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            &demarshaledAttribute,
            4
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    }

    return XME_STATUS_SUCCESS;
}

xme_status_t
doDemarshalingForPnp_componentInstanceManifest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_pnp_componentInstanceManifest_t* topicData
)
{
    const uint32_t marshaledDataSize = 4284;
    unsigned int bytesRead;
    uint8_t marshaledData[4284];
    uint8_t* bufferPtr;
    xme_status_t status;


    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint32_t topicData->nodeId
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = hostValue;
        bufferPtr += 4;
    }
    
    // struct topicData->components
    {
        uint8_t i0;
        
        for (i0 = 0; i0 < 10; i0++)
        {
            // struct topicData->components
            {
                // uint32_t topicData->components[i0].componentId
                {
                    uint32_t hostValue;
                
                    hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
                    topicData->components[i0].componentId = hostValue;
                    bufferPtr += 4;
                }
                
                // uint32_t topicData->components[i0].componentType
                {
                    uint32_t hostValue;
                
                    hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
                    topicData->components[i0].componentType = hostValue;
                    bufferPtr += 4;
                }
                
                // uint32_t topicData->components[i0].componentHandle
                {
                    uint32_t hostValue;
                
                    hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
                    topicData->components[i0].componentHandle = hostValue;
                    bufferPtr += 4;
                }
                
                // char topicData->components[i0].initializationString
                {
                    uint16_t i1;
                    
                    for (i1 = 0; i1 < 256; i1++)
                    {
                        // char topicData->components[i0].initializationString
                        {
                            char hostValue;
                        
                            hostValue = (char)(*(uint8_t*)bufferPtr);
                            topicData->components[i0].initializationString[i1] = hostValue;
                            bufferPtr += sizeof(uint8_t);
                        }
                    }
                }
                
                // struct topicData->components[i0].portData
                {
                    uint8_t i1;
                    
                    for (i1 = 0; i1 < 32; i1++)
                    {
                        // struct topicData->components[i0].portData
                        {
                            // uint8_t topicData->components[i0].portData[i1].queueSize
                            {
                                uint8_t hostValue;
                            
                                hostValue = (uint8_t)(*(uint8_t*)bufferPtr);
                                topicData->components[i0].portData[i1].queueSize = hostValue;
                                bufferPtr += 1;
                            }
                        }
                    }
                }
                
                // struct topicData->components[i0].functionData
                {
                    uint8_t i1;
                    
                    for (i1 = 0; i1 < 16; i1++)
                    {
                        // struct topicData->components[i0].functionData
                        {
                            // uint64_t topicData->components[i0].functionData[i1].executionPeriod
                            {
                                uint64_t hostValue;
                            
                                hostValue = (uint64_t)xme_hal_net_ntohll((*(uint64_t*)bufferPtr));
                                topicData->components[i0].functionData[i1].executionPeriod = hostValue;
                                bufferPtr += 8;
                            }
                        }
                    }
                }
            }
        }
    }

    // Demarshal attributes

    // uint32_t channelID
    {
        uint32_t demarshaledAttribute;
        uint8_t marshaledAttribute[4];
        uint8_t* bufferPtr;
    
        bufferPtr = marshaledAttribute;
    
        status = xme_core_dataHandler_readAttribute
        (
            inputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            marshaledAttribute,
            sizeof(marshaledAttribute),
            &bytesRead
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
        XME_CHECK(bytesRead == sizeof(marshaledAttribute), XME_STATUS_INTERNAL_ERROR);
    
        // uint32_t demarshaledAttribute
        {
            uint32_t hostValue;
        
            hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
            demarshaledAttribute = hostValue;
            bufferPtr += 4;
        }
    
        status = xme_core_dataHandler_writeAttribute
        (
            outputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            &demarshaledAttribute,
            4
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    }

    return XME_STATUS_SUCCESS;
}

xme_status_t
doDemarshalingForPnp_logoutAcknowledgment
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_pnp_logoutAcknowledgment_t* topicData
)
{
    const uint32_t marshaledDataSize = 4;
    unsigned int bytesRead;
    uint8_t marshaledData[4];
    uint8_t* bufferPtr;
    xme_status_t status;


    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint32_t topicData->nodeId
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = hostValue;
        bufferPtr += 4;
    }

    // Demarshal attributes

    // uint32_t channelID
    {
        uint32_t demarshaledAttribute;
        uint8_t marshaledAttribute[4];
        uint8_t* bufferPtr;
    
        bufferPtr = marshaledAttribute;
    
        status = xme_core_dataHandler_readAttribute
        (
            inputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            marshaledAttribute,
            sizeof(marshaledAttribute),
            &bytesRead
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
        XME_CHECK(bytesRead == sizeof(marshaledAttribute), XME_STATUS_INTERNAL_ERROR);
    
        // uint32_t demarshaledAttribute
        {
            uint32_t hostValue;
        
            hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
            demarshaledAttribute = hostValue;
            bufferPtr += 4;
        }
    
        status = xme_core_dataHandler_writeAttribute
        (
            outputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            &demarshaledAttribute,
            4
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    }

    return XME_STATUS_SUCCESS;
}

xme_status_t
doDemarshalingForPnp_logoutRequest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_pnp_logoutRequest_t* topicData
)
{
    const uint32_t marshaledDataSize = 4;
    unsigned int bytesRead;
    uint8_t marshaledData[4];
    uint8_t* bufferPtr;
    xme_status_t status;


    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint32_t topicData->nodeId
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = hostValue;
        bufferPtr += 4;
    }

    // Demarshal attributes

    // uint32_t channelID
    {
        uint32_t demarshaledAttribute;
        uint8_t marshaledAttribute[4];
        uint8_t* bufferPtr;
    
        bufferPtr = marshaledAttribute;
    
        status = xme_core_dataHandler_readAttribute
        (
            inputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            marshaledAttribute,
            sizeof(marshaledAttribute),
            &bytesRead
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
        XME_CHECK(bytesRead == sizeof(marshaledAttribute), XME_STATUS_INTERNAL_ERROR);
    
        // uint32_t demarshaledAttribute
        {
            uint32_t hostValue;
        
            hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
            demarshaledAttribute = hostValue;
            bufferPtr += 4;
        }
    
        status = xme_core_dataHandler_writeAttribute
        (
            outputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            &demarshaledAttribute,
            4
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    }

    return XME_STATUS_SUCCESS;
}

xme_status_t
doDemarshalingForPnp_logoutNotification
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_pnp_logoutNotification_t* topicData
)
{
    const uint32_t marshaledDataSize = 4;
    unsigned int bytesRead;
    uint8_t marshaledData[4];
    uint8_t* bufferPtr;
    xme_status_t status;


    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint32_t topicData->nodeId
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = hostValue;
        bufferPtr += 4;
    }

    // Demarshal attributes

    // uint32_t channelID
    {
        uint32_t demarshaledAttribute;
        uint8_t marshaledAttribute[4];
        uint8_t* bufferPtr;
    
        bufferPtr = marshaledAttribute;
    
        status = xme_core_dataHandler_readAttribute
        (
            inputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            marshaledAttribute,
            sizeof(marshaledAttribute),
            &bytesRead
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
        XME_CHECK(bytesRead == sizeof(marshaledAttribute), XME_STATUS_INTERNAL_ERROR);
    
        // uint32_t demarshaledAttribute
        {
            uint32_t hostValue;
        
            hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
            demarshaledAttribute = hostValue;
            bufferPtr += 4;
        }
    
        status = xme_core_dataHandler_writeAttribute
        (
            outputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            &demarshaledAttribute,
            4
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    }

    return XME_STATUS_SUCCESS;
}

xme_status_t
doDemarshalingForPnp_removeComponentRequest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort,
    xme_core_topic_pnp_removeComponentRequest_t* topicData
)
{
    const uint32_t marshaledDataSize = 8;
    unsigned int bytesRead;
    uint8_t marshaledData[8];
    uint8_t* bufferPtr;
    xme_status_t status;


    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint32_t topicData->nodeId
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = hostValue;
        bufferPtr += 4;
    }
    
    // uint32_t topicData->componentId
    {
        uint32_t hostValue;
    
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->componentId = hostValue;
        bufferPtr += 4;
    }

    // Demarshal attributes

    // uint32_t channelID
    {
        uint32_t demarshaledAttribute;
        uint8_t marshaledAttribute[4];
        uint8_t* bufferPtr;
    
        bufferPtr = marshaledAttribute;
    
        status = xme_core_dataHandler_readAttribute
        (
            inputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            marshaledAttribute,
            sizeof(marshaledAttribute),
            &bytesRead
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
        XME_CHECK(bytesRead == sizeof(marshaledAttribute), XME_STATUS_INTERNAL_ERROR);
    
        // uint32_t demarshaledAttribute
        {
            uint32_t hostValue;
        
            hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
            demarshaledAttribute = hostValue;
            bufferPtr += 4;
        }
    
        status = xme_core_dataHandler_writeAttribute
        (
            outputPort,
            XME_CORE_ATTRIBUTES(XME_CORE_ATTRIBUTE_KEY_CHANNELID),
            &demarshaledAttribute,
            4
        );
    
        XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    }

    return XME_STATUS_SUCCESS;
}

bool
xme_wp_marshal_demarshaler_isSupported
(
    xme_core_topic_t topic
)
{
    uint64_t i;
    size_t supportTopicsLength;

    supportTopicsLength = sizeof(supportedTopics) / sizeof(supportedTopics[0]);

    for (i = 0; i < supportTopicsLength; i++)
    {
        if (topic == supportedTopics[i])
        {
            return true;
        }
    }

    return false;
}
