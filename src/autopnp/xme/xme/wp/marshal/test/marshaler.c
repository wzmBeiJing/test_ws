/*
 * Copyright (c) 2011-2013, fortiss GmbH.
 * Licensed under the Apache License, Version 2.0.
 *
 * Use, modification and distribution are subject to the terms specified
 * in the accompanying license file LICENSE.txt located at the root directory
 * of this software distribution. A copy is available at
 * http://chromosome.fortiss.org/.
 *
 * This file is part of CHROMOSOME.
 *
 * $Id: marshaler.c 7664 2014-03-04 08:47:41Z geisinger $
 */

/**
 * \file
 *
 * \brief  Waypoint that marshals topic data for network transportation.
 *
 * \author
 *         This file has been generated by the CHROMOSOME Modeling Tool (fortiss GmbH).
 */

/******************************************************************************/
/***   Includes                                                             ***/
/******************************************************************************/
#include "marshaler.h"

#include "deMarshalerTestTopic.h"
#include "deMarshalerTestTopicData.h"

#include "xme/hal/include/mem.h"
#include "xme/hal/include/net.h"
#include "xme/hal/include/table.h"

#include "xme/core/dataHandler/include/dataHandler.h"
#include "xme/core/topicData.h"

#include <inttypes.h>

/******************************************************************************/
/***   Type definitions                                                     ***/
/******************************************************************************/
/**
 * \struct configurationItem_t
 *
 * \brief  Structure for storing a configuration for this waypoint.
 */
typedef struct
{
    xme_core_topic_t topic; ///< Topic of the data that is stored at inputPort
    xme_core_dataManager_dataPacketId_t inputPort; ///< InputPort where topic data is stored
    xme_core_dataManager_dataPacketId_t outputPort; ///< OutputPort where marshaled data should be written to
} configurationItem_t;

/******************************************************************************/
/***   Variables                                                            ***/
/******************************************************************************/
/**
 * \brief  Table for storing this waypoints configurations.
 */
static XME_HAL_TABLE
(
    configurationItem_t,
    configurationTable,
    XME_WP_MARSHAL_CONFIGURATIONTABLE_SIZE
);

/**
 * \brief  Constant array that contains all topics that are supported by this
 *         marshaler.
 */
static const xme_core_topic_t
supportedTopics[] =
{
    XME_CORE_TOPIC(XME_WP_DEMARSHALERTEST_TOPIC_TEST),
    XME_CORE_TOPIC(XME_WP_DEMARSHALERTEST_TOPIC_TOPIC0),
    XME_CORE_TOPIC(XME_WP_DEMARSHALERTEST_TOPIC_TOPIC1),
    XME_CORE_TOPIC(XME_WP_DEMARSHALERTEST_TOPIC_TOPIC2),
    XME_CORE_TOPIC(XME_CORE_TOPIC_PNPMANAGER_RUNTIME_GRAPH_MODEL),
    XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_LOGINREQUEST),
    XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_LOGINRESPONSE),
    XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_PNPLOGINREQUEST),
    XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_PNPLOGINRESPONSE),
    XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_LOGINACKNOWLEDGMENT),
    XME_CORE_TOPIC(XME_CORE_TOPIC_PNP_COMPONENTINSTANCEMANIFEST)
};

/******************************************************************************/
/***   Prototypes                                                           ***/
/******************************************************************************/
/**
 * \brief  Performs marshaling on the given topic data.
 *
 * \param  topic      Topic of the data stored at inputPort.
 * \param  inputPort  The inputPort where the data is stored that will be marshaled.
 * \param  outputPort The outputPort where the marshaled data is written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_UNSUPPORTED if the given topic is not supported by this marshaler.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doMarshaling
(
    xme_core_topic_t topic,
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort
);

/**
 * \brief  Performs marshaling for topic 'test'.
 *
 * \param  inputPort Input port where data is stored that will be marshaled.
 * \param  buffer Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doMarshalingForTest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
);
/**
 * \brief  Performs marshaling for topic 'topic0'.
 *
 * \param  inputPort Input port where data is stored that will be marshaled.
 * \param  buffer Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doMarshalingForTopic0
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
);
/**
 * \brief  Performs marshaling for topic 'topic1'.
 *
 * \param  inputPort Input port where data is stored that will be marshaled.
 * \param  buffer Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doMarshalingForTopic1
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
);
/**
 * \brief  Performs marshaling for topic 'topic2'.
 *
 * \param  inputPort Input port where data is stored that will be marshaled.
 * \param  buffer Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doMarshalingForTopic2
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
);
/**
 * \brief  Performs marshaling for topic 'pnpManager_runtime_graph_model'.
 *
 * \param  inputPort Input port where data is stored that will be marshaled.
 * \param  buffer Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doMarshalingForPnpManager_runtime_graph_model
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
);
/**
 * \brief  Performs marshaling for topic 'login_loginRequest'.
 *
 * \param  inputPort Input port where data is stored that will be marshaled.
 * \param  buffer Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doMarshalingForLogin_loginRequest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
);
/**
 * \brief  Performs marshaling for topic 'login_loginResponse'.
 *
 * \param  inputPort Input port where data is stored that will be marshaled.
 * \param  buffer Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doMarshalingForLogin_loginResponse
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
);
/**
 * \brief  Performs marshaling for topic 'login_pnpLoginRequest'.
 *
 * \param  inputPort Input port where data is stored that will be marshaled.
 * \param  buffer Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doMarshalingForLogin_pnpLoginRequest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
);
/**
 * \brief  Performs marshaling for topic 'login_pnpLoginResponse'.
 *
 * \param  inputPort Input port where data is stored that will be marshaled.
 * \param  buffer Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doMarshalingForLogin_pnpLoginResponse
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
);
/**
 * \brief  Performs marshaling for topic 'login_loginAcknowledgment'.
 *
 * \param  inputPort Input port where data is stored that will be marshaled.
 * \param  buffer Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doMarshalingForLogin_loginAcknowledgment
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
);
/**
 * \brief  Performs marshaling for topic 'pnp_componentInstanceManifest'.
 *
 * \param  inputPort Input port where data is stored that will be marshaled.
 * \param  buffer Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doMarshalingForPnp_componentInstanceManifest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
);

/******************************************************************************/
/***   Implementation                                                       ***/
/******************************************************************************/
xme_status_t
xme_wp_marshal_marshaler_init(void)
{
    XME_HAL_TABLE_INIT(configurationTable);

    return XME_STATUS_SUCCESS;
}

xme_status_t
xme_wp_marshal_marshaler_run
(
    xme_wp_waypoint_instanceId_t instanceId
)
{
    xme_status_t status;
    configurationItem_t* configurationItem;

    configurationItem = XME_HAL_TABLE_ITEM_FROM_HANDLE
    (
        configurationTable,
        (xme_hal_table_rowHandle_t)instanceId
    );

    XME_CHECK
    (
        NULL != configurationItem,
        XME_STATUS_INVALID_HANDLE
    );
    
    // Do the marshaling for this configuration
    status = doMarshaling
    (
        configurationItem->topic,
        configurationItem->inputPort,
        configurationItem->outputPort
    );

    XME_CHECK
    (
        XME_STATUS_SUCCESS == status, 
        XME_STATUS_INTERNAL_ERROR
    );

    return XME_STATUS_SUCCESS;
}

xme_status_t
xme_wp_marshal_marshaler_getConfig
(
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_topic_t* topic,
    xme_core_dataManager_dataPacketId_t* inputPort,
    xme_core_dataManager_dataPacketId_t* outputPort
)
{
    xme_hal_table_rowHandle_t rowHandle = XME_HAL_TABLE_INVALID_ROW_HANDLE;
    configurationItem_t* configItem = NULL;
    
    // Check parameters in debug build only
    XME_ASSERT(NULL != instanceId);
    XME_ASSERT(NULL != topic);
    XME_ASSERT(NULL != inputPort);
    XME_ASSERT(NULL != outputPort);
    
    XME_HAL_TABLE_GET_NEXT
    (
        configurationTable,
        xme_hal_table_rowHandle_t,
        rowHandle,
        configurationItem_t,
        configItem,
        (
            (XME_WP_WAYPOINT_INSTANCEID_INVALID == *instanceId  || rowHandle == (xme_hal_table_rowHandle_t)(*instanceId))
            && (XME_CORE_TOPIC_INVALID_TOPIC == *topic  || configItem->topic == *topic)
            && (XME_CORE_DATAMANAGER_DATAPACKETID_INVALID == *inputPort || configItem->inputPort == *inputPort)
            && (XME_CORE_DATAMANAGER_DATAPACKETID_INVALID == *outputPort || configItem->outputPort == *outputPort)
        )
    );
    
    if (XME_HAL_TABLE_INVALID_ROW_HANDLE != rowHandle)
    {
        *instanceId = (xme_wp_waypoint_instanceId_t)rowHandle;
        *topic = configItem->topic;
        *inputPort = configItem->inputPort;
        *outputPort = configItem->outputPort;
        
        return XME_STATUS_SUCCESS;
    }
    
    return XME_STATUS_NOT_FOUND;
}

xme_status_t
xme_wp_marshal_marshaler_addConfig
(
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_topic_t topic,
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort
)
{
    xme_hal_table_rowHandle_t rowHandle;
    configurationItem_t* configurationItem;

    XME_CHECK
    (
        xme_wp_marshal_marshaler_isSupported(topic),
        XME_STATUS_INVALID_PARAMETER
    );

    rowHandle = XME_HAL_TABLE_ADD_ITEM(configurationTable);

    XME_CHECK
    (
        XME_HAL_TABLE_INVALID_ROW_HANDLE != rowHandle,
        XME_STATUS_OUT_OF_RESOURCES
    );

    configurationItem = XME_HAL_TABLE_ITEM_FROM_HANDLE
    (
        configurationTable,
        rowHandle
    );
    
    if (NULL == configurationItem)
    {
        return XME_STATUS_INTERNAL_ERROR;
    }

    configurationItem->topic = topic;
    configurationItem->inputPort = inputPort;
    configurationItem->outputPort = outputPort;

    // We use the row handle to identify this configuration
    *instanceId = (xme_wp_waypoint_instanceId_t)rowHandle;

    return XME_STATUS_SUCCESS;
}

xme_status_t
xme_wp_marshal_marshaler_fini(void)
{
    XME_HAL_TABLE_FINI(configurationTable);

    return XME_STATUS_SUCCESS;
}

xme_status_t
doMarshaling
(
    xme_core_topic_t topic,
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort
)
{
    void* buffer;
    unsigned int bufferSize;
    xme_status_t status;

    // Switch for the correct topic
    // In the respective cases we allocate a buffer with the right size for the topic and
    // call a function that performs the read from the inputPort and the actual marshaling
    if (XME_CORE_TOPIC(XME_WP_DEMARSHALERTEST_TOPIC_TEST) == topic)
    {
        uint8_t marshaledData[90];
        
        buffer = (void*) marshaledData;
        bufferSize = 90;
        
        status = doMarshalingForTest
        (
            inputPort,
            (void*)marshaledData
        );
    }
    else if (XME_CORE_TOPIC(XME_WP_DEMARSHALERTEST_TOPIC_TOPIC0) == topic)
    {
        uint8_t marshaledData[4];
        
        buffer = (void*) marshaledData;
        bufferSize = 4;
        
        status = doMarshalingForTopic0
        (
            inputPort,
            (void*)marshaledData
        );
    }
    else if (XME_CORE_TOPIC(XME_WP_DEMARSHALERTEST_TOPIC_TOPIC1) == topic)
    {
        uint8_t marshaledData[4];
        
        buffer = (void*) marshaledData;
        bufferSize = 4;
        
        status = doMarshalingForTopic1
        (
            inputPort,
            (void*)marshaledData
        );
    }
    else if (XME_CORE_TOPIC(XME_WP_DEMARSHALERTEST_TOPIC_TOPIC2) == topic)
    {
        uint8_t marshaledData[4];
        
        buffer = (void*) marshaledData;
        bufferSize = 4;
        
        status = doMarshalingForTopic2
        (
            inputPort,
            (void*)marshaledData
        );
    }
    else if (XME_CORE_TOPIC(XME_CORE_TOPIC_PNPMANAGER_RUNTIME_GRAPH_MODEL) == topic)
    {
        uint8_t marshaledData[3024];
        
        buffer = (void*) marshaledData;
        bufferSize = 3024;
        
        status = doMarshalingForPnpManager_runtime_graph_model
        (
            inputPort,
            (void*)marshaledData
        );
    }
    else if (XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_LOGINREQUEST) == topic)
    {
        uint8_t marshaledData[18];
        
        buffer = (void*) marshaledData;
        bufferSize = 18;
        
        status = doMarshalingForLogin_loginRequest
        (
            inputPort,
            (void*)marshaledData
        );
    }
    else if (XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_LOGINRESPONSE) == topic)
    {
        uint8_t marshaledData[22];
        
        buffer = (void*) marshaledData;
        bufferSize = 22;
        
        status = doMarshalingForLogin_loginResponse
        (
            inputPort,
            (void*)marshaledData
        );
    }
    else if (XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_PNPLOGINREQUEST) == topic)
    {
        uint8_t marshaledData[10];
        
        buffer = (void*) marshaledData;
        bufferSize = 10;
        
        status = doMarshalingForLogin_pnpLoginRequest
        (
            inputPort,
            (void*)marshaledData
        );
    }
    else if (XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_PNPLOGINRESPONSE) == topic)
    {
        uint8_t marshaledData[10];
        
        buffer = (void*) marshaledData;
        bufferSize = 10;
        
        status = doMarshalingForLogin_pnpLoginResponse
        (
            inputPort,
            (void*)marshaledData
        );
    }
    else if (XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_LOGINACKNOWLEDGMENT) == topic)
    {
        uint8_t marshaledData[4];
        
        buffer = (void*) marshaledData;
        bufferSize = 4;
        
        status = doMarshalingForLogin_loginAcknowledgment
        (
            inputPort,
            (void*)marshaledData
        );
    }
    else if (XME_CORE_TOPIC(XME_CORE_TOPIC_PNP_COMPONENTINSTANCEMANIFEST) == topic)
    {
        uint8_t marshaledData[84];
        
        buffer = (void*) marshaledData;
        bufferSize = 84;
        
        status = doMarshalingForPnp_componentInstanceManifest
        (
            inputPort,
            (void*)marshaledData
        );
    }
    else
    {
        XME_LOG
        (
            XME_LOG_ERROR,
            "xme_wp_marshal_marshaler_run(): Given topic with id %" PRIu64 " is not "
            "supported by this marshaler.",
            topic
        );
        return XME_STATUS_INTERNAL_ERROR;
    }

    XME_CHECK
    (
        XME_STATUS_SUCCESS == status,
        XME_STATUS_INTERNAL_ERROR
    );

    // Write marshaled data to outputPort
    status = xme_core_dataHandler_writeData
    (
        outputPort,
        buffer,
        bufferSize
    );

    XME_CHECK
    (
        XME_STATUS_SUCCESS == status,
        XME_STATUS_INTERNAL_ERROR
    );
    
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_dataHandler_completeWriteOperation(outputPort), XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_dataHandler_completeReadOperation(inputPort), XME_STATUS_INTERNAL_ERROR);

    return XME_STATUS_SUCCESS;
}

xme_status_t
doMarshalingForTest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
)
{
    xme_wp_deMarshalerTest_topic_test_t topicData;
    unsigned int topicDataSize;
    unsigned int bytesRead;
    uint8_t* bufferPtr;
    xme_status_t status;

    topicDataSize = sizeof(xme_wp_deMarshalerTest_topic_test_t);

    // Read topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        &topicData,
        topicDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == topicDataSize, XME_STATUS_INTERNAL_ERROR);

    // Marshal topic data
    bufferPtr = (uint8_t*)buffer;
    
    // bool topicData.flag
    {
        uint8_t netValue;
    
        netValue = topicData.flag ? 0x01 : 0x00;
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint8_t));
        bufferPtr += sizeof(uint8_t);
    }
    
    // uint8_t topicData.uint8
    {
        uint8_t netValue;
        
        netValue = (uint8_t)topicData.uint8;
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint8_t));
        bufferPtr += sizeof(uint8_t);
    }
    
    // uint16_t topicData.uint16
    {
        uint16_t netValue;
        
        netValue = xme_hal_net_htons((uint16_t)topicData.uint16);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint16_t));
        bufferPtr += sizeof(uint16_t);
    }
    
    // uint32_t topicData.uint32
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.uint32);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    // uint64_t topicData.uint64
    {
        uint64_t netValue;
        
        netValue = xme_hal_net_htonll((uint64_t)topicData.uint64);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint64_t));
        bufferPtr += sizeof(uint64_t);
    }
    
    // int8_t topicData.int8
    {
        uint8_t netValue;
        
        netValue = (uint8_t)topicData.int8;
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint8_t));
        bufferPtr += sizeof(uint8_t);
    }
    
    // int16_t topicData.int16
    {
        uint16_t netValue;
        
        netValue = xme_hal_net_htons((uint16_t)topicData.int16);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint16_t));
        bufferPtr += sizeof(uint16_t);
    }
    
    // int32_t topicData.int32
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.int32);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    // int64_t topicData.int64
    {
        uint64_t netValue;
        
        netValue = xme_hal_net_htonll((uint64_t)topicData.int64);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint64_t));
        bufferPtr += sizeof(uint64_t);
    }
    
    // float topicData.f
    {
        // Note that the marshaler assumes binary32 (IEEE 754) storage format for float
        
        union
        {
            uint32_t i;
            float f;
        } value;
        
        value.f = topicData.f;
        
        value.i = xme_hal_net_htonl(value.i);
        (void) xme_hal_mem_copy(bufferPtr, &value, 4);
        bufferPtr += 4;
    }
    
    // double topicData.d
    {
        // Note that the marshaler assumes binary64 (IEEE 754) storage format for double
        
        union
        {
            uint64_t i;
            double d;
        } value;
        
        value.d = topicData.d;
        
        value.i = xme_hal_net_htonll(value.i);
        (void) xme_hal_mem_copy(bufferPtr, &value, 8);
        bufferPtr += 8;
    }        
    
    // char topicData.c
    (void) xme_hal_mem_copy(bufferPtr, &topicData.c, sizeof(char));
    bufferPtr += sizeof(char);
    
    // enum topicData.e
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.e);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    // uint16_t topicData.array0
    {
        uint8_t i0;
        
        for (i0 = 0; i0 < 3; i0++)
        {
            // uint16_t topicData.array0[i0]
            {
                uint16_t netValue;
                
                netValue = xme_hal_net_htons((uint16_t)topicData.array0[i0]);
                (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint16_t));
                bufferPtr += sizeof(uint16_t);
            }
        }
    }
    
    // uint16_t topicData.array1
    {
        uint8_t i0;
        uint8_t i1;
        
        for (i0 = 0; i0 < 2; i0++)
        {
            for (i1 = 0; i1 < 3; i1++)
            {
                // uint16_t topicData.array1[i0][i1]
                {
                    uint16_t netValue;
                    
                    netValue = xme_hal_net_htons((uint16_t)topicData.array1[i0][i1]);
                    (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint16_t));
                    bufferPtr += sizeof(uint16_t);
                }
            }
        }
    }
    
    // struct topicData.subStruct
    {
        // uint16_t topicData.subStruct.uint16
        {
            uint16_t netValue;
            
            netValue = xme_hal_net_htons((uint16_t)topicData.subStruct.uint16);
            (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint16_t));
            bufferPtr += sizeof(uint16_t);
        }
        
        // uint16_t topicData.subStruct.a
        {
            uint8_t i0;
            
            for (i0 = 0; i0 < 3; i0++)
            {
                // uint16_t topicData.subStruct.a[i0]
                {
                    uint16_t netValue;
                    
                    netValue = xme_hal_net_htons((uint16_t)topicData.subStruct.a[i0]);
                    (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint16_t));
                    bufferPtr += sizeof(uint16_t);
                }
            }
        }
        
        // struct topicData.subStruct.subSubStruct
        {
            // bool topicData.subStruct.subSubStruct.flag0
            {
                uint8_t netValue;
            
                netValue = topicData.subStruct.subSubStruct.flag0 ? 0x01 : 0x00;
                (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint8_t));
                bufferPtr += sizeof(uint8_t);
            }
            
            // bool topicData.subStruct.subSubStruct.flag1
            {
                uint8_t netValue;
            
                netValue = topicData.subStruct.subSubStruct.flag1 ? 0x01 : 0x00;
                (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint8_t));
                bufferPtr += sizeof(uint8_t);
            }
        }
    }
    
    // struct topicData.array2
    {
        uint8_t i0;
        
        for (i0 = 0; i0 < 2; i0++)
        {
            // struct topicData.array2[i0]
            {
                // bool topicData.array2[i0].flag0
                {
                    uint8_t netValue;
                
                    netValue = topicData.array2[i0].flag0 ? 0x01 : 0x00;
                    (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint8_t));
                    bufferPtr += sizeof(uint8_t);
                }
                
                // bool topicData.array2[i0].flag1
                {
                    uint8_t netValue;
                
                    netValue = topicData.array2[i0].flag1 ? 0x01 : 0x00;
                    (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint8_t));
                    bufferPtr += sizeof(uint8_t);
                }
            }
        }
    }
    
    // struct topicData.array3
    {
        uint8_t i0;
        
        for (i0 = 0; i0 < 1; i0++)
        {
            // struct topicData.array3[i0]
            {
                // char topicData.array3[i0].x
                {
                    uint8_t i1;
                    
                    for (i1 = 0; i1 < 2; i1++)
                    {
                        // char topicData.array3[i0].x[i1]
                        (void) xme_hal_mem_copy(bufferPtr, &topicData.array3[i0].x[i1], sizeof(char));
                        bufferPtr += sizeof(char);
                    }
                }
                
                // struct topicData.array3[i0].y
                {
                    uint8_t i1;
                    
                    for (i1 = 0; i1 < 2; i1++)
                    {
                        // struct topicData.array3[i0].y[i1]
                        {
                            // char topicData.array3[i0].y[i1].c
                            {
                                uint8_t i2;
                                
                                for (i2 = 0; i2 < 2; i2++)
                                {
                                    // char topicData.array3[i0].y[i1].c[i2]
                                    (void) xme_hal_mem_copy(bufferPtr, &topicData.array3[i0].y[i1].c[i2], sizeof(char));
                                    bufferPtr += sizeof(char);
                                }
                            }
                        }
                    }
                }
                
                // struct topicData.array3[i0].z
                {
                    uint8_t i1;
                    
                    for (i1 = 0; i1 < 2; i1++)
                    {
                        // struct topicData.array3[i0].z[i1]
                        {
                            // char topicData.array3[i0].z[i1].c
                            {
                                uint8_t i2;
                                
                                for (i2 = 0; i2 < 2; i2++)
                                {
                                    // char topicData.array3[i0].z[i1].c[i2]
                                    (void) xme_hal_mem_copy(bufferPtr, &topicData.array3[i0].z[i1].c[i2], sizeof(char));
                                    bufferPtr += sizeof(char);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doMarshalingForTopic0
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
)
{
    xme_wp_deMarshalerTest_topic_topic0_t topicData;
    unsigned int topicDataSize;
    unsigned int bytesRead;
    uint8_t* bufferPtr;
    xme_status_t status;

    topicDataSize = sizeof(xme_wp_deMarshalerTest_topic_topic0_t);

    // Read topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        &topicData,
        topicDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == topicDataSize, XME_STATUS_INTERNAL_ERROR);

    // Marshal topic data
    bufferPtr = (uint8_t*)buffer;
    
    // uint32_t topicData.test
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.test);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doMarshalingForTopic1
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
)
{
    xme_wp_deMarshalerTest_topic_topic1_t topicData;
    unsigned int topicDataSize;
    unsigned int bytesRead;
    uint8_t* bufferPtr;
    xme_status_t status;

    topicDataSize = sizeof(xme_wp_deMarshalerTest_topic_topic1_t);

    // Read topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        &topicData,
        topicDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == topicDataSize, XME_STATUS_INTERNAL_ERROR);

    // Marshal topic data
    bufferPtr = (uint8_t*)buffer;
    
    // uint32_t topicData.test
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.test);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doMarshalingForTopic2
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
)
{
    xme_wp_deMarshalerTest_topic_topic2_t topicData;
    unsigned int topicDataSize;
    unsigned int bytesRead;
    uint8_t* bufferPtr;
    xme_status_t status;

    topicDataSize = sizeof(xme_wp_deMarshalerTest_topic_topic2_t);

    // Read topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        &topicData,
        topicDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == topicDataSize, XME_STATUS_INTERNAL_ERROR);

    // Marshal topic data
    bufferPtr = (uint8_t*)buffer;
    
    // uint32_t topicData.test
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.test);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doMarshalingForPnpManager_runtime_graph_model
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
)
{
    xme_core_topic_pnpManager_runtime_graph_model_t topicData;
    unsigned int topicDataSize;
    unsigned int bytesRead;
    uint8_t* bufferPtr;
    xme_status_t status;

    topicDataSize = sizeof(xme_core_topic_pnpManager_runtime_graph_model_t);

    // Read topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        &topicData,
        topicDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == topicDataSize, XME_STATUS_INTERNAL_ERROR);

    // Marshal topic data
    bufferPtr = (uint8_t*)buffer;
    
    // uint32_t topicData.nodeId
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.nodeId);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    // struct topicData.vertex
    {
        uint8_t i0;
        
        for (i0 = 0; i0 < 10; i0++)
        {
            // struct topicData.vertex[i0]
            {
                // enum topicData.vertex[i0].vertexType
                {
                    uint32_t netValue;
                    
                    netValue = xme_hal_net_htonl((uint32_t)topicData.vertex[i0].vertexType);
                    (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
                    bufferPtr += sizeof(uint32_t);
                }
                
                // char topicData.vertex[i0].vertexData
                {
                    uint16_t i1;
                    
                    for (i1 = 0; i1 < 256; i1++)
                    {
                        // char topicData.vertex[i0].vertexData[i1]
                        (void) xme_hal_mem_copy(bufferPtr, &topicData.vertex[i0].vertexData[i1], sizeof(char));
                        bufferPtr += sizeof(char);
                    }
                }
                
                // uint32_t topicData.vertex[i0].instanceId
                {
                    uint32_t netValue;
                    
                    netValue = xme_hal_net_htonl((uint32_t)topicData.vertex[i0].componentId);
                    (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
                    bufferPtr += sizeof(uint32_t);
                }
            }
        }
    }
    
    // struct topicData.edge
    {
        uint8_t i0;
        
        for (i0 = 0; i0 < 10; i0++)
        {
            // struct topicData.edge[i0]
            {
                // uint8_t topicData.edge[i0].srcVertexIndex
                {
                    uint8_t netValue;
                    
                    netValue = (uint8_t)topicData.edge[i0].srcVertexIndex;
                    (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint8_t));
                    bufferPtr += sizeof(uint8_t);
                }
                
                // uint8_t topicData.edge[i0].sinkVertexIndex
                {
                    uint8_t netValue;
                    
                    netValue = (uint8_t)topicData.edge[i0].sinkVertexIndex;
                    (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint8_t));
                    bufferPtr += sizeof(uint8_t);
                }
                
                // enum topicData.edge[i0].edgeType
                {
                    uint32_t netValue;
                    
                    netValue = xme_hal_net_htonl((uint32_t)topicData.edge[i0].edgeType);
                    (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
                    bufferPtr += sizeof(uint32_t);
                }
                
                // char topicData.edge[i0].edgeData
                {
                    uint8_t i1;
                    
                    for (i1 = 0; i1 < 32; i1++)
                    {
                        // char topicData.edge[i0].edgeData[i1]
                        (void) xme_hal_mem_copy(bufferPtr, &topicData.edge[i0].edgeData[i1], sizeof(char));
                        bufferPtr += sizeof(char);
                    }
                }
            }
        }
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doMarshalingForLogin_loginRequest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
)
{
    xme_core_topic_login_loginRequest_t topicData;
    unsigned int topicDataSize;
    unsigned int bytesRead;
    uint8_t* bufferPtr;
    xme_status_t status;

    topicDataSize = sizeof(xme_core_topic_login_loginRequest_t);

    // Read topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        &topicData,
        topicDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == topicDataSize, XME_STATUS_INTERNAL_ERROR);

    // Marshal topic data
    bufferPtr = (uint8_t*)buffer;
    
    // uint64_t topicData.guid
    {
        uint64_t netValue;
        
        netValue = xme_hal_net_htonll((uint64_t)topicData.guid);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint64_t));
        bufferPtr += sizeof(uint64_t);
    }
    
    // uint32_t topicData.nodeId
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.nodeId);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    // uint32_t topicData.ipAddress
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.ipAddress);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    // uint16_t topicData.portAddress
    {
        uint16_t netValue;
        
        netValue = xme_hal_net_htons((uint16_t)topicData.portAddress);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint16_t));
        bufferPtr += sizeof(uint16_t);
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doMarshalingForLogin_loginResponse
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
)
{
    xme_core_topic_login_loginResponse_t topicData;
    unsigned int topicDataSize;
    unsigned int bytesRead;
    uint8_t* bufferPtr;
    xme_status_t status;

    topicDataSize = sizeof(xme_core_topic_login_loginResponse_t);

    // Read topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        &topicData,
        topicDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == topicDataSize, XME_STATUS_INTERNAL_ERROR);

    // Marshal topic data
    bufferPtr = (uint8_t*)buffer;
    
    // enum topicData.loginStatus
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.loginStatus);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    // uint64_t topicData.guid
    {
        uint64_t netValue;
        
        netValue = xme_hal_net_htonll((uint64_t)topicData.guid);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint64_t));
        bufferPtr += sizeof(uint64_t);
    }
    
    // uint32_t topicData.nodeId
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.nodeId);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    // uint32_t topicData.ipAddress
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.ipAddress);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    // uint16_t topicData.portAddress
    {
        uint16_t netValue;
        
        netValue = xme_hal_net_htons((uint16_t)topicData.portAddress);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint16_t));
        bufferPtr += sizeof(uint16_t);
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doMarshalingForLogin_pnpLoginRequest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
)
{
    xme_core_topic_login_pnpLoginRequest_t topicData;
    unsigned int topicDataSize;
    unsigned int bytesRead;
    uint8_t* bufferPtr;
    xme_status_t status;

    topicDataSize = sizeof(xme_core_topic_login_pnpLoginRequest_t);

    // Read topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        &topicData,
        topicDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == topicDataSize, XME_STATUS_INTERNAL_ERROR);

    // Marshal topic data
    bufferPtr = (uint8_t*)buffer;
    
    // uint32_t topicData.nodeId
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.nodeId);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    // uint32_t topicData.ipAddress
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.ipAddress);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    // uint16_t topicData.portAddress
    {
        uint16_t netValue;
        
        netValue = xme_hal_net_htons((uint16_t)topicData.portAddress);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint16_t));
        bufferPtr += sizeof(uint16_t);
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doMarshalingForLogin_pnpLoginResponse
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
)
{
    xme_core_topic_login_pnpLoginResponse_t topicData;
    unsigned int topicDataSize;
    unsigned int bytesRead;
    uint8_t* bufferPtr;
    xme_status_t status;

    topicDataSize = sizeof(xme_core_topic_login_pnpLoginResponse_t);

    // Read topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        &topicData,
        topicDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == topicDataSize, XME_STATUS_INTERNAL_ERROR);

    // Marshal topic data
    bufferPtr = (uint8_t*)buffer;
    
    // uint32_t topicData.nodeId
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.nodeId);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    // uint32_t topicData.ipAddress
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.ipAddress);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    // uint16_t topicData.portAddress
    {
        uint16_t netValue;
        
        netValue = xme_hal_net_htons((uint16_t)topicData.portAddress);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint16_t));
        bufferPtr += sizeof(uint16_t);
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doMarshalingForLogin_loginAcknowledgment
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
)
{
    xme_core_topic_login_loginAcknowledgment_t topicData;
    unsigned int topicDataSize;
    unsigned int bytesRead;
    uint8_t* bufferPtr;
    xme_status_t status;

    topicDataSize = sizeof(xme_core_topic_login_loginAcknowledgment_t);

    // Read topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        &topicData,
        topicDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == topicDataSize, XME_STATUS_INTERNAL_ERROR);

    // Marshal topic data
    bufferPtr = (uint8_t*)buffer;
    
    // uint32_t topicData.nodeId
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.nodeId);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doMarshalingForPnp_componentInstanceManifest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    void* buffer
)
{
    xme_core_topic_pnp_componentInstanceManifest_t topicData;
    unsigned int topicDataSize;
    unsigned int bytesRead;
    uint8_t* bufferPtr;
    xme_status_t status;

    topicDataSize = sizeof(xme_core_topic_pnp_componentInstanceManifest_t);

    // Read topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        &topicData,
        topicDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == topicDataSize, XME_STATUS_INTERNAL_ERROR);

    // Marshal topic data
    bufferPtr = (uint8_t*)buffer;
    
    // uint32_t topicData.nodeId
    {
        uint32_t netValue;
        
        netValue = xme_hal_net_htonl((uint32_t)topicData.nodeId);
        (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
    }
    
    // struct topicData.components
    {
        uint8_t i0;
        
        for (i0 = 0; i0 < 10; i0++)
        {
            // struct topicData.components[i0]
            {
                // uint32_t topicData.components[i0].componentId
                {
                    uint32_t netValue;
                    
                    netValue = xme_hal_net_htonl((uint32_t)topicData.components[i0].componentId);
                    (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
                    bufferPtr += sizeof(uint32_t);
                }
                
                // uint32_t topicData.components[i0].componentType
                {
                    uint32_t netValue;
                    
                    netValue = xme_hal_net_htonl((uint32_t)topicData.components[i0].componentType);
                    (void) xme_hal_mem_copy(bufferPtr, &netValue, sizeof(uint32_t));
                    bufferPtr += sizeof(uint32_t);
                }
            }
        }
    }
    
    return XME_STATUS_SUCCESS;
}

bool
xme_wp_marshal_marshaler_isSupported
(
    xme_core_topic_t topic
)
{
    uint64_t i;
    size_t supportTopicsLength;
    
    supportTopicsLength = sizeof(supportedTopics) / sizeof(supportedTopics[0]);
    
    for (i = 0; i < supportTopicsLength; i++)
    {
        if (topic == supportedTopics[i])
        {
            return true;
        }
    }
    
    return false;
}
