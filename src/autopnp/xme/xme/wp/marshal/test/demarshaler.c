/*
 * Copyright (c) 2011-2013, fortiss GmbH.
 * Licensed under the Apache License, Version 2.0.
 *
 * Use, modification and distribution are subject to the terms specified
 * in the accompanying license file LICENSE.txt located at the root directory
 * of this software distribution. A copy is available at
 * http://chromosome.fortiss.org/.
 *
 * This file is part of CHROMOSOME.
 *
 * $Id: demarshaler.c 7664 2014-03-04 08:47:41Z geisinger $
 */

/**
 * \file
 *
 * \brief  Waypoint that demarshals topic data.
 *
 * \author
 *         This file has been generated by the CHROMOSOME Modeling Tool (fortiss GmbH).
 */

/******************************************************************************/
/***   Includes                                                             ***/
/******************************************************************************/
#include "demarshaler.h"

#include "deMarshalerTestTopic.h"
#include "deMarshalerTestTopicData.h"

#include "xme/hal/include/mem.h"
#include "xme/hal/include/net.h"
#include "xme/hal/include/table.h"

#include "xme/core/dataHandler/include/dataHandler.h"
#include "xme/core/topicData.h"

#include <inttypes.h>

/******************************************************************************/
/***   Type definitions                                                     ***/
/******************************************************************************/
/**
 * \struct configurationItem_t
 *
 * \brief  Structure for storing waypoint configuration.
 */
typedef struct
{
    xme_core_topic_t topic; ///< Topic of the data that is stored at inputPort
    xme_core_dataManager_dataPacketId_t inputPort; ///< InputPort where topic data is stored
    xme_core_dataManager_dataPacketId_t outputPort; ///< OutputPort where marshaled data should be written to
} configurationItem_t;

/******************************************************************************/
/***   Variables                                                            ***/
/******************************************************************************/
/**
 * \brief  Table for storing this waypoints configurations.
 */
static XME_HAL_TABLE
(
    configurationItem_t,
    configurationTable,
    XME_WP_MARSHAL_CONFIGURATIONTABLE_SIZE
);

/**
 * \brief  Constant array that contains all topics that are supported by this
 *         marshaler.
 */
static const xme_core_topic_t
supportedTopics[] =
{
    XME_CORE_TOPIC(XME_WP_DEMARSHALERTEST_TOPIC_TEST),
    XME_CORE_TOPIC(XME_WP_DEMARSHALERTEST_TOPIC_TOPIC0),
    XME_CORE_TOPIC(XME_WP_DEMARSHALERTEST_TOPIC_TOPIC1),
    XME_CORE_TOPIC(XME_WP_DEMARSHALERTEST_TOPIC_TOPIC2),
    XME_CORE_TOPIC(XME_CORE_TOPIC_PNPMANAGER_RUNTIME_GRAPH_MODEL),
    XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_LOGINREQUEST),
    XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_LOGINRESPONSE),
    XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_PNPLOGINREQUEST),
    XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_PNPLOGINRESPONSE),
    XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_LOGINACKNOWLEDGMENT),
    XME_CORE_TOPIC(XME_CORE_TOPIC_PNP_COMPONENTINSTANCEMANIFEST)
};

/******************************************************************************/
/***   Prototypes                                                           ***/
/******************************************************************************/
/**
 * \brief  Performs demarshaling on the given data.
 *
 * \param  topic      Topic of the data stored at inputPort.
 * \param  inputPort  The inputPort where the marshaled data is stored.
 * \param  outputPort The outputPort where the demarshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_UNSUPPORTED if the given topic is not supported by this marshaler.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshaling
(
    xme_core_topic_t topic,
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort
);

/**
 * \brief  Performs demarshaling for topic 'test'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForTest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_wp_deMarshalerTest_topic_test_t* topicData
);
/**
 * \brief  Performs demarshaling for topic 'topic0'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForTopic0
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_wp_deMarshalerTest_topic_topic0_t* topicData
);
/**
 * \brief  Performs demarshaling for topic 'topic1'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForTopic1
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_wp_deMarshalerTest_topic_topic1_t* topicData
);
/**
 * \brief  Performs demarshaling for topic 'topic2'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForTopic2
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_wp_deMarshalerTest_topic_topic2_t* topicData
);
/**
 * \brief  Performs demarshaling for topic 'pnpManager_runtime_graph_model'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForPnpManager_runtime_graph_model
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_topic_pnpManager_runtime_graph_model_t* topicData
);
/**
 * \brief  Performs demarshaling for topic 'login_loginRequest'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForLogin_loginRequest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_topic_login_loginRequest_t* topicData
);
/**
 * \brief  Performs demarshaling for topic 'login_loginResponse'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForLogin_loginResponse
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_topic_login_loginResponse_t* topicData
);
/**
 * \brief  Performs demarshaling for topic 'login_pnpLoginRequest'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForLogin_pnpLoginRequest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_topic_login_pnpLoginRequest_t* topicData
);
/**
 * \brief  Performs demarshaling for topic 'login_pnpLoginResponse'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForLogin_pnpLoginResponse
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_topic_login_pnpLoginResponse_t* topicData
);
/**
 * \brief  Performs demarshaling for topic 'login_loginAcknowledgment'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForLogin_loginAcknowledgment
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_topic_login_loginAcknowledgment_t* topicData
);
/**
 * \brief  Performs demarshaling for topic 'pnp_componentInstanceManifest'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForPnp_componentInstanceManifest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_topic_pnp_componentInstanceManifest_t* topicData
);

/******************************************************************************/
/***   Implementation                                                       ***/
/******************************************************************************/
xme_status_t
xme_wp_marshal_demarshaler_init(void)
{
    XME_HAL_TABLE_INIT(configurationTable);

    return XME_STATUS_SUCCESS;
}

xme_status_t
xme_wp_marshal_demarshaler_run
(
    xme_wp_waypoint_instanceId_t instanceId
)
{
    xme_status_t status;
    configurationItem_t* configurationItem;

    configurationItem = XME_HAL_TABLE_ITEM_FROM_HANDLE
    (
        configurationTable, 
        (xme_hal_table_rowHandle_t)instanceId
    );

    XME_CHECK
    (
        NULL != configurationItem,
        XME_STATUS_INVALID_HANDLE
    );
    
    // Do the marshaling for this configuration
    status = doDemarshaling
    (
        configurationItem->topic,    
        configurationItem->inputPort, 
        configurationItem->outputPort
    );

    XME_CHECK
    (
        XME_STATUS_SUCCESS == status, 
        XME_STATUS_INTERNAL_ERROR
    );

    return XME_STATUS_SUCCESS;
}

xme_status_t
xme_wp_marshal_demarshaler_getConfig
(
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_topic_t* topic,
    xme_core_dataManager_dataPacketId_t* inputPort,
    xme_core_dataManager_dataPacketId_t* outputPort
)
{
    xme_hal_table_rowHandle_t rowHandle = XME_HAL_TABLE_INVALID_ROW_HANDLE;
    configurationItem_t* item = NULL;
            
    // Check parameters in debug build only
    XME_ASSERT(NULL != instanceId);
    XME_ASSERT(NULL != topic);
    XME_ASSERT(NULL != inputPort);
    XME_ASSERT(NULL != outputPort);
            
    XME_HAL_TABLE_GET_NEXT
    (
        configurationTable,
        xme_hal_table_rowHandle_t,
        rowHandle,
        configurationItem_t,
        item,
        (
            (XME_WP_WAYPOINT_INSTANCEID_INVALID == *instanceId  || rowHandle == (xme_hal_table_rowHandle_t)(*instanceId))
            && (XME_CORE_TOPIC_INVALID_TOPIC == *topic  || item->topic == *topic)
            && (XME_CORE_DATAMANAGER_DATAPACKETID_INVALID == *inputPort || item->inputPort == *inputPort)
            && (XME_CORE_DATAMANAGER_DATAPACKETID_INVALID == *outputPort || item->outputPort == *outputPort)
        )
    );
            
    if (XME_HAL_TABLE_INVALID_ROW_HANDLE != rowHandle)
    {
        *instanceId = (xme_wp_waypoint_instanceId_t)rowHandle;
        *topic = item->topic;
        *inputPort = item->inputPort;
        *outputPort = item->outputPort;
                
        return XME_STATUS_SUCCESS;
    }
            
    return XME_STATUS_NOT_FOUND;
}

xme_status_t
xme_wp_marshal_demarshaler_addConfig
(
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_topic_t topic,
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort
)
{
    xme_hal_table_rowHandle_t configurationItemHandle;
    configurationItem_t* configurationItem;

    XME_CHECK
    (
        xme_wp_marshal_demarshaler_isSupported(topic),
        XME_STATUS_INVALID_PARAMETER
    );

    configurationItemHandle = XME_HAL_TABLE_ADD_ITEM(configurationTable);

    XME_CHECK
    (
        XME_HAL_TABLE_INVALID_ROW_HANDLE != configurationItemHandle,
        XME_STATUS_OUT_OF_RESOURCES
    );

    configurationItem = XME_HAL_TABLE_ITEM_FROM_HANDLE
    (
        configurationTable, 
        configurationItemHandle
    );
    
    XME_ASSERT(NULL != configurationItem);

    configurationItem->topic = topic;
    configurationItem->inputPort = inputPort;
    configurationItem->outputPort = outputPort;

    // We use the row handle to identify this configuration
    *instanceId = (xme_wp_waypoint_instanceId_t)configurationItemHandle;

    return XME_STATUS_SUCCESS;
}

xme_status_t
xme_wp_marshal_demarshaler_fini(void)
{
    XME_HAL_TABLE_FINI(configurationTable);

    return XME_STATUS_SUCCESS;
}

xme_status_t
doDemarshaling
(
    xme_core_topic_t topic,
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_dataManager_dataPacketId_t outputPort
)
{
    void* buffer;
    unsigned int bufferSize;
    xme_status_t status;

    // Switch for the correct topic
    // In the respective cases we allocate a buffer with the right size for the topic and
    // call a function that performs the read from the inputPort and the actual demarshaling
    if (XME_CORE_TOPIC(XME_WP_DEMARSHALERTEST_TOPIC_TEST) == topic)
    {
        xme_wp_deMarshalerTest_topic_test_t topicData;
        
        buffer = (void*) &topicData;
        bufferSize = sizeof(xme_wp_deMarshalerTest_topic_test_t);
        
        status = doDemarshalingForTest
        (
            inputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC(XME_WP_DEMARSHALERTEST_TOPIC_TOPIC0) == topic)
    {
        xme_wp_deMarshalerTest_topic_topic0_t topicData;
        
        buffer = (void*) &topicData;
        bufferSize = sizeof(xme_wp_deMarshalerTest_topic_topic0_t);
        
        status = doDemarshalingForTopic0
        (
            inputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC(XME_WP_DEMARSHALERTEST_TOPIC_TOPIC1) == topic)
    {
        xme_wp_deMarshalerTest_topic_topic1_t topicData;
        
        buffer = (void*) &topicData;
        bufferSize = sizeof(xme_wp_deMarshalerTest_topic_topic1_t);
        
        status = doDemarshalingForTopic1
        (
            inputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC(XME_WP_DEMARSHALERTEST_TOPIC_TOPIC2) == topic)
    {
        xme_wp_deMarshalerTest_topic_topic2_t topicData;
        
        buffer = (void*) &topicData;
        bufferSize = sizeof(xme_wp_deMarshalerTest_topic_topic2_t);
        
        status = doDemarshalingForTopic2
        (
            inputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC(XME_CORE_TOPIC_PNPMANAGER_RUNTIME_GRAPH_MODEL) == topic)
    {
        xme_core_topic_pnpManager_runtime_graph_model_t topicData;
        
        buffer = (void*) &topicData;
        bufferSize = sizeof(xme_core_topic_pnpManager_runtime_graph_model_t);
        
        status = doDemarshalingForPnpManager_runtime_graph_model
        (
            inputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_LOGINREQUEST) == topic)
    {
        xme_core_topic_login_loginRequest_t topicData;
        
        buffer = (void*) &topicData;
        bufferSize = sizeof(xme_core_topic_login_loginRequest_t);
        
        status = doDemarshalingForLogin_loginRequest
        (
            inputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_LOGINRESPONSE) == topic)
    {
        xme_core_topic_login_loginResponse_t topicData;
        
        buffer = (void*) &topicData;
        bufferSize = sizeof(xme_core_topic_login_loginResponse_t);
        
        status = doDemarshalingForLogin_loginResponse
        (
            inputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_PNPLOGINREQUEST) == topic)
    {
        xme_core_topic_login_pnpLoginRequest_t topicData;
        
        buffer = (void*) &topicData;
        bufferSize = sizeof(xme_core_topic_login_pnpLoginRequest_t);
        
        status = doDemarshalingForLogin_pnpLoginRequest
        (
            inputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_PNPLOGINRESPONSE) == topic)
    {
        xme_core_topic_login_pnpLoginResponse_t topicData;
        
        buffer = (void*) &topicData;
        bufferSize = sizeof(xme_core_topic_login_pnpLoginResponse_t);
        
        status = doDemarshalingForLogin_pnpLoginResponse
        (
            inputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC(XME_CORE_TOPIC_LOGIN_LOGINACKNOWLEDGMENT) == topic)
    {
        xme_core_topic_login_loginAcknowledgment_t topicData;
        
        buffer = (void*) &topicData;
        bufferSize = sizeof(xme_core_topic_login_loginAcknowledgment_t);
        
        status = doDemarshalingForLogin_loginAcknowledgment
        (
            inputPort,
            &topicData
        );
    }
    else if (XME_CORE_TOPIC(XME_CORE_TOPIC_PNP_COMPONENTINSTANCEMANIFEST) == topic)
    {
        xme_core_topic_pnp_componentInstanceManifest_t topicData;
        
        buffer = (void*) &topicData;
        bufferSize = sizeof(xme_core_topic_pnp_componentInstanceManifest_t);
        
        status = doDemarshalingForPnp_componentInstanceManifest
        (
            inputPort,
            &topicData
        );
    }
    else
    {
        XME_LOG
        (
            XME_LOG_ERROR, 
            "xme_wp_marshal_demarshaler_run(): Given topic with id %" PRIu64 " is not "
            "supported by this demarshaler.",
            topic
        );
        return XME_STATUS_INTERNAL_ERROR;
    }

    XME_CHECK
    (
        XME_STATUS_SUCCESS == status,
        XME_STATUS_INTERNAL_ERROR
    );

    // Write marshaled data to outputPort
    status = xme_core_dataHandler_writeData
    (
        outputPort,
        buffer,
        bufferSize
    );

    XME_CHECK
    (
        XME_STATUS_SUCCESS == status,
        XME_STATUS_INTERNAL_ERROR
    );
    
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_dataHandler_completeWriteOperation(outputPort), XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_dataHandler_completeReadOperation(inputPort), XME_STATUS_INTERNAL_ERROR);

    return XME_STATUS_SUCCESS;
}

xme_status_t
doDemarshalingForTest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_wp_deMarshalerTest_topic_test_t* topicData
)
{
    const uint32_t marshaledDataSize = 90;
    unsigned int bytesRead;
    uint8_t marshaledData[90];
    uint8_t* bufferPtr;
    xme_status_t status;
    
    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // bool topicData->flag
    {
        bool hostValue;
    
        hostValue = (0x00 == *(uint8_t*)bufferPtr) ? false : true;
        topicData->flag = hostValue;
        bufferPtr += 1;
    }
    
    // uint8_t topicData->uint8
    {
        int8_t hostValue;
        
        hostValue = (int8_t)(*(uint8_t*)bufferPtr);
        topicData->uint8 = hostValue;
        bufferPtr += 1;
    }
    
    // uint16_t topicData->uint16
    {
        int16_t hostValue;
        
        hostValue = (int16_t)xme_hal_net_ntohs((*(uint16_t*)bufferPtr));
        topicData->uint16 = hostValue;
        bufferPtr += 2;
    }
    
    // uint32_t topicData->uint32
    {
        int32_t hostValue;
        
        hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->uint32 = hostValue;
        bufferPtr += 4;
    }
    
    // uint64_t topicData->uint64
    {
        int64_t hostValue;
        
        hostValue = (int64_t)xme_hal_net_ntohll((*(uint64_t*)bufferPtr));
        topicData->uint64 = hostValue;
        bufferPtr += 8;
    }
    
    // int8_t topicData->int8
    {
        uint8_t hostValue;
        
        hostValue = (uint8_t)(*(uint8_t*)bufferPtr);
        topicData->int8 = hostValue;
        bufferPtr += 1;
    }
    
    // int16_t topicData->int16
    {
        uint16_t hostValue;
        
        hostValue = (uint16_t)xme_hal_net_ntohs((*(uint16_t*)bufferPtr));
        topicData->int16 = hostValue;
        bufferPtr += 2;
    }
    
    // int32_t topicData->int32
    {
        uint32_t hostValue;
        
        hostValue = (uint32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->int32 = hostValue;
        bufferPtr += 4;
    }
    
    // int64_t topicData->int64
    {
        uint64_t hostValue;
        
        hostValue = (uint64_t)xme_hal_net_ntohll((*(uint64_t*)bufferPtr));
        topicData->int64 = hostValue;
        bufferPtr += 8;
    }
    
    // float topicData->f
    {
        // Note that the marshaler assumes binary32 (IEEE 754) storage format for float
        
        union
        {
            uint32_t i;
            float f;
        } hostValue;
        
        hostValue.i = xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->f = hostValue.f;
        bufferPtr += 4;
    }
    
    // double topicData->d
    {
        // Note that the marshaler assumes binary64 (IEEE 754) storage format for double
        
        union
        {
            uint64_t i;
            double d;
        } hostValue;
        
        hostValue.i = xme_hal_net_ntohll((*(uint64_t*)bufferPtr));
        topicData->d = hostValue.d;
        bufferPtr += 8;
    }
    
    // char topicData->c
    {
        char hostValue;
        
        hostValue = (char)(*(uint8_t*)bufferPtr);
        topicData->c = hostValue;
        bufferPtr += 1;
    }
    
    // enum topicData->e
    {
        uint32_t hostValue;
        
        hostValue = xme_hal_net_ntohl(*((uint32_t*)bufferPtr));
        (void) xme_hal_mem_set(&topicData->e, 0, sizeof(topicData->e));
        (void) xme_hal_mem_copy(&topicData->e, &hostValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
        
        // Check if enum on this platform is big enough to hold demarshaled value
        XME_ASSERT(hostValue <= (uint32_t)(1 << (8 * sizeof(XME_WP_DEMARSHALERTEST_TOPIC_TEST_E_A) - 1)));
        if (hostValue > (uint32_t)(1 << (8 * sizeof(XME_WP_DEMARSHALERTEST_TOPIC_TEST_E_A) - 1)))
        {
            XME_LOG
            (
                XME_LOG_WARNING,
                "Error: Enumeration value overflow (%" PRIu32 " > %" PRIu32 ") while demarshaling!\n",
                hostValue, (1 << (8 * sizeof(XME_WP_DEMARSHALERTEST_TOPIC_TEST_E_A) - 1))
            );
        }
    }
    
    // uint16_t topicData->array0
    {
        uint8_t i0;
        
        for (i0 = 0; i0 < 3; i0++)
        {
            // uint16_t topicData->array0
            {
                int16_t hostValue;
                
                hostValue = (int16_t)xme_hal_net_ntohs((*(uint16_t*)bufferPtr));
                topicData->array0[i0] = hostValue;
                bufferPtr += 2;
            }
        }
    }
    
    // uint16_t topicData->array1
    {
        uint8_t i0;
        uint8_t i1;
        
        for (i0 = 0; i0 < 2; i0++)
        {
            for (i1 = 0; i1 < 3; i1++)
            {
                // uint16_t topicData->array1[i0]
                {
                    int16_t hostValue;
                    
                    hostValue = (int16_t)xme_hal_net_ntohs((*(uint16_t*)bufferPtr));
                    topicData->array1[i0][i1] = hostValue;
                    bufferPtr += 2;
                }
            }
        }
    }
    
    // struct topicData->subStruct
    {
        // uint16_t topicData->subStruct.uint16
        {
            int16_t hostValue;
            
            hostValue = (int16_t)xme_hal_net_ntohs((*(uint16_t*)bufferPtr));
            topicData->subStruct.uint16 = hostValue;
            bufferPtr += 2;
        }
        
        // uint16_t topicData->subStruct.a
        {
            uint8_t i0;
            
            for (i0 = 0; i0 < 3; i0++)
            {
                // uint16_t topicData->subStruct.a
                {
                    int16_t hostValue;
                    
                    hostValue = (int16_t)xme_hal_net_ntohs((*(uint16_t*)bufferPtr));
                    topicData->subStruct.a[i0] = hostValue;
                    bufferPtr += 2;
                }
            }
        }
        
        // struct topicData->subStruct.subSubStruct
        {
            // bool topicData->subStruct.subSubStruct.flag0
            {
                bool hostValue;
            
                hostValue = (0x00 == *(uint8_t*)bufferPtr) ? false : true;
                topicData->subStruct.subSubStruct.flag0 = hostValue;
                bufferPtr += 1;
            }
            
            // bool topicData->subStruct.subSubStruct.flag1
            {
                bool hostValue;
            
                hostValue = (0x00 == *(uint8_t*)bufferPtr) ? false : true;
                topicData->subStruct.subSubStruct.flag1 = hostValue;
                bufferPtr += 1;
            }
        }
    }
    
    // struct topicData->array2
    {
        uint8_t i0;
        
        for (i0 = 0; i0 < 2; i0++)
        {
            // struct topicData->array2
            {
                // bool topicData->array2[i0].flag0
                {
                    bool hostValue;
                
                    hostValue = (0x00 == *(uint8_t*)bufferPtr) ? false : true;
                    topicData->array2[i0].flag0 = hostValue;
                    bufferPtr += 1;
                }
                
                // bool topicData->array2[i0].flag1
                {
                    bool hostValue;
                
                    hostValue = (0x00 == *(uint8_t*)bufferPtr) ? false : true;
                    topicData->array2[i0].flag1 = hostValue;
                    bufferPtr += 1;
                }
            }
        }
    }
    
    // struct topicData->array3
    {
        uint8_t i0;
        
        for (i0 = 0; i0 < 1; i0++)
        {
            // struct topicData->array3
            {
                // char topicData->array3[i0].x
                {
                    uint8_t i1;
                    
                    for (i1 = 0; i1 < 2; i1++)
                    {
                        // char topicData->array3[i0].x
                        {
                            char hostValue;
                            
                            hostValue = (char)(*(uint8_t*)bufferPtr);
                            topicData->array3[i0].x[i1] = hostValue;
                            bufferPtr += 1;
                        }
                    }
                }
                
                // struct topicData->array3[i0].y
                {
                    uint8_t i1;
                    
                    for (i1 = 0; i1 < 2; i1++)
                    {
                        // struct topicData->array3[i0].y
                        {
                            // char topicData->array3[i0].y[i1].c
                            {
                                uint8_t i2;
                                
                                for (i2 = 0; i2 < 2; i2++)
                                {
                                    // char topicData->array3[i0].y[i1].c
                                    {
                                        char hostValue;
                                        
                                        hostValue = (char)(*(uint8_t*)bufferPtr);
                                        topicData->array3[i0].y[i1].c[i2] = hostValue;
                                        bufferPtr += 1;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // struct topicData->array3[i0].z
                {
                    uint8_t i1;
                    
                    for (i1 = 0; i1 < 2; i1++)
                    {
                        // struct topicData->array3[i0].z
                        {
                            // char topicData->array3[i0].z[i1].c
                            {
                                uint8_t i2;
                                
                                for (i2 = 0; i2 < 2; i2++)
                                {
                                    // char topicData->array3[i0].z[i1].c
                                    {
                                        char hostValue;
                                        
                                        hostValue = (char)(*(uint8_t*)bufferPtr);
                                        topicData->array3[i0].z[i1].c[i2] = hostValue;
                                        bufferPtr += 1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doDemarshalingForTopic0
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_wp_deMarshalerTest_topic_topic0_t* topicData
)
{
    const uint32_t marshaledDataSize = 4;
    unsigned int bytesRead;
    uint8_t marshaledData[4];
    uint8_t* bufferPtr;
    xme_status_t status;
    
    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint32_t topicData->test
    {
        int32_t hostValue;
        
        hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->test = hostValue;
        bufferPtr += 4;
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doDemarshalingForTopic1
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_wp_deMarshalerTest_topic_topic1_t* topicData
)
{
    const uint32_t marshaledDataSize = 4;
    unsigned int bytesRead;
    uint8_t marshaledData[4];
    uint8_t* bufferPtr;
    xme_status_t status;
    
    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint32_t topicData->test
    {
        int32_t hostValue;
        
        hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->test = hostValue;
        bufferPtr += 4;
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doDemarshalingForTopic2
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_wp_deMarshalerTest_topic_topic2_t* topicData
)
{
    const uint32_t marshaledDataSize = 4;
    unsigned int bytesRead;
    uint8_t marshaledData[4];
    uint8_t* bufferPtr;
    xme_status_t status;
    
    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint32_t topicData->test
    {
        int32_t hostValue;
        
        hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->test = hostValue;
        bufferPtr += 4;
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doDemarshalingForPnpManager_runtime_graph_model
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_topic_pnpManager_runtime_graph_model_t* topicData
)
{
    const uint32_t marshaledDataSize = 3024;
    unsigned int bytesRead;
    uint8_t marshaledData[3024];
    uint8_t* bufferPtr;
    xme_status_t status;
    
    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint32_t topicData->nodeId
    {
        int32_t hostValue;
        
        hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = (xme_core_node_nodeId_t) hostValue;
        bufferPtr += 4;
    }
    
    // struct topicData->vertex
    {
        uint8_t i0;
        
        for (i0 = 0; i0 < 10; i0++)
        {
            // struct topicData->vertex
            {
                // enum topicData->vertex[i0].vertexType
                {
                    uint32_t hostValue;
                    
                    hostValue = xme_hal_net_ntohl(*((uint32_t*)bufferPtr));
                    (void) xme_hal_mem_set(&topicData->vertex[i0].vertexType, 0, sizeof(topicData->vertex[i0].vertexType));
                    (void) xme_hal_mem_copy(&topicData->vertex[i0].vertexType, &hostValue, sizeof(uint32_t));
                    bufferPtr += sizeof(uint32_t);
                    
                    // Check if enum on this platform is big enough to hold demarshaled value
                    XME_ASSERT(hostValue <= (uint32_t)(1 << (8 * sizeof(XME_CORE_PNP_DATALINKGRAPH_VERTEXTYPE_INVALID_VERTEXTYPE) - 1)));
                    if (hostValue > (uint32_t)(1 << (8 * sizeof(XME_CORE_PNP_DATALINKGRAPH_VERTEXTYPE_INVALID_VERTEXTYPE) - 1)))
                    {
                        XME_LOG
                        (
                            XME_LOG_WARNING,
                            "Error: Enumeration value overflow (%" PRIu32 " > %" PRIu32 ") while demarshaling!\n",
                            hostValue, (1 << (8 * sizeof(XME_CORE_PNP_DATALINKGRAPH_VERTEXTYPE_INVALID_VERTEXTYPE) - 1))
                        );
                    }
                }
                
                // char topicData->vertex[i0].vertexData
                {
                    uint16_t i1;
                    
                    for (i1 = 0; i1 < 256; i1++)
                    {
                        // char topicData->vertex[i0].vertexData
                        {
                            char hostValue;
                            
                            hostValue = (char)(*(uint8_t*)bufferPtr);
                            topicData->vertex[i0].vertexData[i1] = hostValue;
                            bufferPtr += 1;
                        }
                    }
                }
                
                // uint32_t topicData->vertex[i0].instanceId
                {
                    int32_t hostValue;
                    
                    hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
                    topicData->vertex[i0].componentId = (xme_core_component_t) hostValue;
                    bufferPtr += 4;
                }
            }
        }
    }
    
    // struct topicData->edge
    {
        uint8_t i0;
        
        for (i0 = 0; i0 < 10; i0++)
        {
            // struct topicData->edge
            {
                // uint8_t topicData->edge[i0].srcVertexIndex
                {
                    int8_t hostValue;
                    
                    hostValue = (int8_t)(*(uint8_t*)bufferPtr);
                    topicData->edge[i0].srcVertexIndex = hostValue;
                    bufferPtr += 1;
                }
                
                // uint8_t topicData->edge[i0].sinkVertexIndex
                {
                    int8_t hostValue;
                    
                    hostValue = (int8_t)(*(uint8_t*)bufferPtr);
                    topicData->edge[i0].sinkVertexIndex = hostValue;
                    bufferPtr += 1;
                }
                
                // enum topicData->edge[i0].edgeType
                {
                    uint32_t hostValue;
                    
                    hostValue = xme_hal_net_ntohl(*((uint32_t*)bufferPtr));
                    (void) xme_hal_mem_set(&topicData->edge[i0].edgeType, 0, sizeof(topicData->edge[i0].edgeType));
                    (void) xme_hal_mem_copy(&topicData->edge[i0].edgeType, &hostValue, sizeof(uint32_t));
                    bufferPtr += sizeof(uint32_t);
                    
                    // Check if enum on this platform is big enough to hold demarshaled value
                    XME_ASSERT(hostValue <= (uint32_t)(1 << (8 * sizeof(XME_CORE_PNP_DATALINKGRAPH_EDGETYPE_INVALID_EDGETYPE) - 1)));
                    if (hostValue > (uint32_t)(1 << (8 * sizeof(XME_CORE_PNP_DATALINKGRAPH_EDGETYPE_INVALID_EDGETYPE) - 1)))
                    {
                        XME_LOG
                        (
                            XME_LOG_WARNING,
                            "Error: Enumeration value overflow (%" PRIu32 " > %" PRIu32 ") while demarshaling!\n",
                            hostValue, (1 << (8 * sizeof(XME_CORE_PNP_DATALINKGRAPH_EDGETYPE_INVALID_EDGETYPE) - 1))
                        );
                    }
                }
                
                // char topicData->edge[i0].edgeData
                {
                    uint8_t i1;
                    
                    for (i1 = 0; i1 < 32; i1++)
                    {
                        // char topicData->edge[i0].edgeData
                        {
                            char hostValue;
                            
                            hostValue = (char)(*(uint8_t*)bufferPtr);
                            topicData->edge[i0].edgeData[i1] = hostValue;
                            bufferPtr += 1;
                        }
                    }
                }
            }
        }
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doDemarshalingForLogin_loginRequest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_topic_login_loginRequest_t* topicData
)
{
    const uint32_t marshaledDataSize = 18;
    uint32_t bytesRead;
    uint8_t marshaledData[18];
    uint8_t* bufferPtr;
    xme_status_t status;
    
    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint64_t topicData->guid
    {
        int64_t hostValue;
        
        hostValue = (int64_t)xme_hal_net_ntohll((*(uint64_t*)bufferPtr));
        topicData->guid = hostValue;
        bufferPtr += 8;
    }
    
    // uint32_t topicData->nodeId
    {
        int32_t hostValue;
        
        hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = (xme_core_node_nodeId_t) hostValue;
        bufferPtr += 4;
    }
    
    // uint32_t topicData->ipAddress
    {
        int32_t hostValue;
        
        hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->ipAddress = hostValue;
        bufferPtr += 4;
    }
    
    // uint16_t topicData->portAddress
    {
        int16_t hostValue;
        
        hostValue = (int16_t)xme_hal_net_ntohs((*(uint16_t*)bufferPtr));
        topicData->portAddress = hostValue;
        bufferPtr += 2;
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doDemarshalingForLogin_loginResponse
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_topic_login_loginResponse_t* topicData
)
{
    const uint32_t marshaledDataSize = 22;
    unsigned int bytesRead;
    uint8_t marshaledData[22];
    uint8_t* bufferPtr;
    xme_status_t status;
    
    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // enum topicData->loginStatus
    {
        uint32_t hostValue;
        
        hostValue = xme_hal_net_ntohl(*((uint32_t*)bufferPtr));
        (void) xme_hal_mem_set(&topicData->loginStatus, 0, sizeof(topicData->loginStatus));
        (void) xme_hal_mem_copy(&topicData->loginStatus, &hostValue, sizeof(uint32_t));
        bufferPtr += sizeof(uint32_t);
        
        // Check if enum on this platform is big enough to hold demarshaled value
        XME_ASSERT(hostValue <= (uint32_t)(1 << (8 * sizeof(XME_CORE_TOPIC_LOGIN_LOGINRESPONSE_LOGINSTATUS_LOGIN_SUCCESS) - 1)));
        if (hostValue > (uint32_t)(1 << (8 * sizeof(XME_CORE_TOPIC_LOGIN_LOGINRESPONSE_LOGINSTATUS_LOGIN_SUCCESS) - 1)))
        {
            XME_LOG
            (
                XME_LOG_WARNING,
                "Error: Enumeration value overflow (%" PRIu32 " > %" PRIu32 ") while demarshaling!\n",
                hostValue, (1 << (8 * sizeof(XME_CORE_TOPIC_LOGIN_LOGINRESPONSE_LOGINSTATUS_LOGIN_SUCCESS) - 1))
            );
        }
    }
    
    // uint64_t topicData->guid
    {
        int64_t hostValue;
        
        hostValue = (int64_t)xme_hal_net_ntohll((*(uint64_t*)bufferPtr));
        topicData->guid = hostValue;
        bufferPtr += 8;
    }
    
    // uint32_t topicData->nodeId
    {
        int32_t hostValue;
        
        hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = (xme_core_node_nodeId_t) hostValue;
        bufferPtr += 4;
    }
    
    // uint32_t topicData->ipAddress
    {
        int32_t hostValue;
        
        hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->ipAddress = hostValue;
        bufferPtr += 4;
    }
    
    // uint16_t topicData->portAddress
    {
        int16_t hostValue;
        
        hostValue = (int16_t)xme_hal_net_ntohs((*(uint16_t*)bufferPtr));
        topicData->portAddress = hostValue;
        bufferPtr += 2;
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doDemarshalingForLogin_pnpLoginRequest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_topic_login_pnpLoginRequest_t* topicData
)
{
    const uint32_t marshaledDataSize = 10;
    unsigned int bytesRead;
    uint8_t marshaledData[10];
    uint8_t* bufferPtr;
    xme_status_t status;
    
    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint32_t topicData->nodeId
    {
        int32_t hostValue;
        
        hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = (xme_core_node_nodeId_t) hostValue;
        bufferPtr += 4;
    }
    
    // uint32_t topicData->ipAddress
    {
        int32_t hostValue;
        
        hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->ipAddress = hostValue;
        bufferPtr += 4;
    }
    
    // uint16_t topicData->portAddress
    {
        int16_t hostValue;
        
        hostValue = (int16_t)xme_hal_net_ntohs((*(uint16_t*)bufferPtr));
        topicData->portAddress = hostValue;
        bufferPtr += 2;
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doDemarshalingForLogin_pnpLoginResponse
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_topic_login_pnpLoginResponse_t* topicData
)
{
    const uint32_t marshaledDataSize = 10;
    unsigned int bytesRead;
    uint8_t marshaledData[10];
    uint8_t* bufferPtr;
    xme_status_t status;
    
    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint32_t topicData->nodeId
    {
        int32_t hostValue;
        
        hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = (xme_core_node_nodeId_t) hostValue;
        bufferPtr += 4;
    }
    
    // uint32_t topicData->ipAddress
    {
        int32_t hostValue;
        
        hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->ipAddress = hostValue;
        bufferPtr += 4;
    }
    
    // uint16_t topicData->portAddress
    {
        int16_t hostValue;
        
        hostValue = (int16_t)xme_hal_net_ntohs((*(uint16_t*)bufferPtr));
        topicData->portAddress = hostValue;
        bufferPtr += 2;
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doDemarshalingForLogin_loginAcknowledgment
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_topic_login_loginAcknowledgment_t* topicData
)
{
    const uint32_t marshaledDataSize = 4;
    unsigned int bytesRead;
    uint8_t marshaledData[4];
    uint8_t* bufferPtr;
    xme_status_t status;
    
    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint32_t topicData->nodeId
    {
        int32_t hostValue;
        
        hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = (xme_core_node_nodeId_t) hostValue;
        bufferPtr += 4;
    }
    
    return XME_STATUS_SUCCESS;
}
xme_status_t
doDemarshalingForPnp_componentInstanceManifest
(
    xme_core_dataManager_dataPacketId_t inputPort,
    xme_core_topic_pnp_componentInstanceManifest_t* topicData
)
{
    const uint32_t marshaledDataSize = 84;
    unsigned int bytesRead;
    uint8_t marshaledData[84];
    uint8_t* bufferPtr;
    xme_status_t status;
    
    bufferPtr = marshaledData;

    // Read marshaled topic data
    status = xme_core_dataHandler_readData
    (
        inputPort,
        bufferPtr,
        marshaledDataSize,
        &bytesRead
    );

    XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
    XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

    // Demarshal data
    
    // uint32_t topicData->nodeId
    {
        int32_t hostValue;
        
        hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
        topicData->nodeId = (xme_core_node_nodeId_t) hostValue;
        bufferPtr += 4;
    }
    
    // struct topicData->components
    {
        uint8_t i0;
        
        for (i0 = 0; i0 < 10; i0++)
        {
            // struct topicData->components
            {
                // uint32_t topicData->components[i0].componentId
                {
                    int32_t hostValue;
                    
                    hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
                    topicData->components[i0].componentId = (xme_core_component_t) hostValue;
                    bufferPtr += 4;
                }
                
                // uint32_t topicData->components[i0].componentType
                {
                    int32_t hostValue;
                    
                    hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
                    topicData->components[i0].componentType = (xme_core_componentType_t) hostValue;
                    bufferPtr += 4;
                }
            }
        }
    }
    
    return XME_STATUS_SUCCESS;
}

bool
xme_wp_marshal_demarshaler_isSupported
(
    xme_core_topic_t topic
)
{
    uint64_t i;
    size_t supportTopicsLength;
    
    supportTopicsLength = sizeof(supportedTopics) / sizeof(supportedTopics[0]);
    
    for (i = 0; i < supportTopicsLength; i++)
    {
        if (topic == supportedTopics[i])
        {
            return true;
        }
    }
    
    return false;
}

